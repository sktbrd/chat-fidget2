"use strict";var e=require("../../lib/solana/transaction.js");async function a({tx:a,accessToken:r,walletProxy:t,entropyId:n,entropyIdVerifier:s,transactingWalletAddress:i,transactingWalletIndex:o}){let l=e.getWalletPublicKeyFromTransaction(a,i),c=e.isVersionedTransaction(a)?Buffer.from(a.message.serialize()):a.serializeMessage(),{response:d}=await t.rpc({accessToken:r,entropyId:n,entropyIdVerifier:s,chainType:"solana",hdWalletIndex:o,request:{method:"signMessage",params:{message:c.toString("base64")}}}),g=d.data.signature;a.addSignature(l,Buffer.from(g,"base64"))}require("../../utils/buffer/readBigInt64LE.js"),exports.sendSolanaTransaction=async function({tx:e,connection:r,accessToken:t,walletProxy:n,entropyId:s,entropyIdVerifier:i,transactingWalletAddress:o,transactingWalletIndex:l,transactionOptions:c}){let d;try{await a({tx:e,accessToken:t,walletProxy:n,entropyId:s,entropyIdVerifier:i,transactingWalletAddress:o,transactingWalletIndex:l});let g=e.serialize();d=await r.sendRawTransaction(g,c);let u=await r.confirmTransaction(d);if(u.value.err||u.value.err){let e=u.value.err||u.value.err;if("string"==typeof e)throw Error(e);throw e}return{signature:d,receipt:await r.getParsedTransaction(d,{maxSupportedTransactionVersion:0})}}catch(e){throw e.txSignature=d,e}},exports.signSolanaTransaction=a;
