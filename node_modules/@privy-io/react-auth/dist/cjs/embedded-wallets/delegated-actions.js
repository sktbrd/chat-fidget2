"use strict";var e=require("../client/user.js"),r=require("../errors.js");require("@ethersproject/address"),require("ofetch");const t=e=>e.linkedAccounts.filter((e=>"wallet"===e.type&&"privy"===e.walletClientType&&e.delegated));exports.getDelegatedWalletsData=({address:e,user:t})=>{let s=t.linkedAccounts.find((r=>"wallet"===r.type&&"privy"===r.walletClientType&&r.address===e));if(!s)throw new r.PrivyClientError("Address to delegate is not associated with current user.");return{address:s.address,chainType:s.chainType,walletIndex:s.walletIndex??0}},exports.getDelegatedWalletsForUser=t,exports.getRootWalletDataForDelegation=({address:t,user:s})=>{let d,a=s.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType&&e.address===t));if(!a)throw new r.PrivyClientError("Address to delegate is not associated with current user.");if(!(d="ethereum"===a.chainType?a.imported?e.getImportedPrivyEthereumWallet(s):e.getPrivyEthereumWallet(s):a))throw new r.PrivyClientError("Unable to determine root address for delegated address.");return{address:d.address,chainType:d.chainType,imported:d.imported}},exports.isWalletDelegated=({address:e,chainType:r,user:s})=>!!t(s).find((t=>t.address===e&&t.chainType===r));
