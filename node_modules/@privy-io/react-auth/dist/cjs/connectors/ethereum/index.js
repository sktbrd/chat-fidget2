"use strict";var e=require("@ethersproject/address"),t=require("@ethersproject/providers"),r=require("../../constants.js"),i=require("../../errors.js"),n=require("../../storage.js"),s=require("../../utils/index.js"),o=require("../areWalletArraysEqual.js"),a=require("../base.js"),c=require("../getRpcTimeout.js"),d=require("../privyProxyProvider.js");require("ofetch"),require("../get-legacy-injected-providers.js"),require("../is-wallet-installed.js"),require("../isBaseConnectedEthereumWallet.js"),require("eventemitter3"),require("../errors.js"),require("@ethersproject/logger"),require("@privy-io/js-sdk-core");class l extends a.WalletConnector{buildConnectedWallet(r,n,o,a){let c=async()=>!!this.wallets.find((t=>e.getAddress(t.address)===e.getAddress(r)));return{type:"ethereum",address:e.getAddress(r),chainId:n,meta:o,imported:a,switchChain:async t=>{let o,a;if(!c)throw new i.PrivyConnectorError("Wallet is not currently connected.");let d=this.wallets.find((t=>e.getAddress(t.address)===e.getAddress(r)))?.chainId;if(!d)throw new i.PrivyConnectorError("Unable to determine current chainId.");if("number"==typeof t?(o=`0x${t.toString(16)}`,a=t):(o=t,a=Number(t)),d===s.formatChainIdToCAIP2(o))return;let l=this.chains.find((e=>e.id===a));if(!l)throw new i.PrivyConnectorError(`Unsupported chainId: ${t}`);let h=async()=>{await this.proxyProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:o}]})};try{return await h()}catch(e){if(((e,t)=>"coinbase_wallet"===t?e.message.includes("addEthereumChain"):4902===e.code||e.message?.includes("4902"))(e,this.walletClientType))return await this.proxyProvider.request({method:"wallet_addEthereumChain",params:[{chainId:o,chainName:l.name,nativeCurrency:l.nativeCurrency,rpcUrls:[l.rpcUrls.default?.http[0]??""],blockExplorerUrls:[l.blockExplorers?.default.url??""]}]}),h();if("rainbow"===this.walletClientType&&e.message?.includes("wallet_switchEthereumChain"))throw new i.PrivyConnectorError(`Rainbow does not support the chainId ${n}`);throw e}},connectedAt:Date.now(),walletClientType:this.walletClientType,connectorType:this.connectorType,isConnected:c,getEthereumProvider:async()=>{if(!await c())throw new i.PrivyConnectorError("Wallet is not currently connected.");return this.proxyProvider},getEthersProvider:async()=>{if(!await c())throw new i.PrivyConnectorError("Wallet is not currently connected.");return new t.Web3Provider(new d.AsExternalProvider(this.proxyProvider))},getWeb3jsProvider:async()=>{if(!await c())throw new i.PrivyConnectorError("Wallet is not currently connected.");return new d.AsAbstractProvider(this.proxyProvider)},sign:async e=>{if(!await c())throw new i.PrivyConnectorError("Wallet is not currently connected.");return await this.sign(e)},disconnect:()=>{this.disconnect()}}}async syncAccounts(t){let i,a=t;try{if(void 0===a){let e=await s.invokeUntilSettled((()=>this.proxyProvider.request({method:"eth_accounts"})),{maxAttempts:10,delayMs:500});console.debug(`eth_accounts for ${this.walletClientType}:`,e),Array.isArray(e)&&(a=e)}}catch(e){console.debug("Wallet did not respond to eth_accounts. Defaulting to prefetched accounts.",e)}if(!a||!Array.isArray(a)||a.length<=0||!a[0])return;let c=a[0],d=e.getAddress(c),l=[];if("privy"===this.walletClientType){let e=n.default.get(r.getPrivyWalletKey(d));this.chains.find((t=>t.id===Number(e)))||(n.default.del(r.getPrivyWalletKey(d)),e=null),i=e||`0x${this.defaultChain.id.toString(16)}`;try{await this.proxyProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:i}]})}catch(e){console.warn(`Unable to switch embedded wallet to chain ID ${i} on initialization`)}}else try{let e=await s.invokeUntilSettled((()=>this.proxyProvider.request({method:"eth_chainId"})),{maxAttempts:10,delayMs:500});if(console.debug(`eth_chainId for ${this.walletClientType}:`,e),"string"==typeof e)i=e;else{if("number"!=typeof e)throw Error("Invalid chainId returned from provider");i=`0x${e.toString(16)}`}}catch(e){console.warn(`Failed to get chainId from provider, defaulting to ${r.DEFAULT_NETWORK}`,e),i=r.DEFAULT_NETWORK}let h=s.formatChainIdToCAIP2(i);if(!l.find((t=>e.getAddress(t.address)===d))){let t={name:this.walletBranding.name,icon:"string"==typeof this.walletBranding.icon?this.walletBranding.icon:void 0,id:this.walletBranding.id};l.push(this.buildConnectedWallet(e.getAddress(c),h,t,"embedded_imported"===this.connectorType))}o.areWalletArraysEqual(l,this.wallets)||(this.wallets=l,this.emit("walletsUpdated"))}async getConnectedWallet(){let t=await this.proxyProvider.request({method:"eth_accounts"});return this.wallets.sort(((e,t)=>t.connectedAt-e.connectedAt)).find((r=>t.find((t=>e.getAddress(t)===e.getAddress(r.address)))))||null}async isConnected(){let e=await this.proxyProvider.request({method:"eth_accounts"});return Array.isArray(e)&&e.length>0}async sign(e){return await this.connect({showPrompt:!1}),new t.Web3Provider(new d.AsExternalProvider(this.proxyProvider)).getSigner().signMessage(e)}subscribeListeners(){this.proxyProvider.on("accountsChanged",this.onAccountsChanged),this.proxyProvider.on("chainChanged",this.onChainChanged),this.proxyProvider.on("disconnect",this.onDisconnect),this.proxyProvider.on("connect",this.onConnect)}unsubscribeListeners(){this.proxyProvider.removeListener("accountsChanged",this.onAccountsChanged),this.proxyProvider.removeListener("chainChanged",this.onChainChanged),this.proxyProvider.removeListener("disconnect",this.onDisconnect),this.proxyProvider.removeListener("connect",this.onConnect)}constructor(e,t,i,o){super(e),this.chainType="ethereum",this.onAccountsChanged=e=>{0===e.length?this.onDisconnect():this.syncAccounts(e)},this.onChainChanged=e=>{this.wallets.forEach((t=>{t.chainId=s.formatChainIdToCAIP2(e),"privy"===this.walletClientType&&n.default.put(r.getPrivyWalletKey(t.address),e)})),this.emit("walletsUpdated")},this.onDisconnect=()=>{this.connected=!1,this.wallets=[],this.emit("walletsUpdated")},this.onConnect=()=>{this.connected=!0,this.syncAccounts()},this.wallets=[],this.walletClientType=e,this.chains=t,this.defaultChain=i,this.rpcConfig=o,this.rpcTimeoutDuration=c.getRpcTimeout(o,e),this.connected=!1,this.initialized=!1}}exports.EthereumWalletConnector=l,exports.isEthereumWalletConnector=function(e){return"ethereum"===e.chainType};
