"use strict";var e=require("../errors.js"),t=require("../svg/browser-extension-wallet-icon.js"),r=require("../svg/metamask.js"),i=require("../svg/phantom.js"),n=require("./errors.js"),o=require("./ethereum/index.js"),s=require("./privyProxyProvider.js");function a(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}require("ofetch"),require("react/jsx-runtime"),require("@ethersproject/logger"),require("@privy-io/js-sdk-core"),require("@ethersproject/address"),require("@ethersproject/providers"),require("../constants.js"),require("../storage.js"),require("../utils/index.js"),require("./get-legacy-injected-providers.js"),require("./is-wallet-installed.js"),require("./areWalletArraysEqual.js"),require("./isBaseConnectedEthereumWallet.js"),require("./base.js"),require("eventemitter3"),require("./getRpcTimeout.js");var c=0;class l extends o.EthereumWalletConnector{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}get walletBranding(){return{name:this.providerDetail.info.name,icon:this.providerDetail.info.icon,id:this.providerDetail.info.rdns}}disconnect(){console.warn(`Programmatic disconnect with ${this.providerDetail.info.name} is not yet supported.`)}async promptConnection(){try{let t=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!t||0===t.length||!t[0])throw new e.PrivyConnectorError("Unable to retrieve accounts");await this.syncAccounts([t[0]])}catch(e){throw n.formatConnectorError(e)}}constructor(e,t,r,i,n){super(n||"unknown",e,t,r),this.connectorType="injected",this.proxyProvider=new s.PrivyProxyProvider(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.providerDetail=i;let o=i.provider;this.proxyProvider.setWalletProvider(o)}}var u="__private_"+c+++"__walletBranding";class h extends o.EthereumWalletConnector{async initialize(){await this.syncAccounts(),this.initialized=!0,this.emit("initialized")}async connect(e){return e.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}get walletBranding(){return a(this,u)[u]??{name:"Browser Extension",icon:t.BrowserExtensionWallet,id:"extension"}}disconnect(){console.warn("Programmatic disconnect with browser wallets is not yet supported.")}async promptConnection(){try{let t=await this.proxyProvider.request({method:"eth_requestAccounts"});if(!t||0===t.length||!t[0])throw new e.PrivyConnectorError("Unable to retrieve accounts");await this.syncAccounts([t[0]])}catch(e){throw n.formatConnectorError(e)}}constructor(e,t,n,o,c){super(c??"unknown",e,t,n),Object.defineProperty(this,u,{writable:!0,value:void 0}),this.connectorType="injected",this.proxyProvider=new s.PrivyProxyProvider(void 0,this.rpcTimeoutDuration),this.subscribeListeners(),this.proxyProvider.setWalletProvider(o),"metamask"===c?a(this,u)[u]={name:"MetaMask",icon:r.Metamask,id:"io.metamask"}:"phantom"===c&&(a(this,u)[u]={name:"Phantom",icon:i.Phantom,id:"phantom"})}}exports.Injected6963WalletConnector=l,exports.LegacyInjectedWalletConnector=h;
