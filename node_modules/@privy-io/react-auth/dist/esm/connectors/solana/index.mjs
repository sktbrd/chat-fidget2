import{notImplementedWithMessage as t}from"../../hooks/index.mjs";import{isWalletClientType as e}from"../../types.mjs";import{WalletConnector as n}from"../base.mjs";import{formatConnectorError as s}from"../errors.mjs";import"eventemitter3";import"@ethersproject/logger";import"@privy-io/js-sdk-core";import"../../errors.mjs";import"ofetch";function i(t){return"solana"===t.chainType}function a(t){return"solana"===t.type}class o extends n{get isInstalled(){return"Installed"===this.adapter.readyState}buildConnectedWallet(e,n){let s,i,a;if("Installed"!==e.readyState||!e.publicKey)throw Error("Wallet is not connected.");return"signMessage"in e&&(s=async(...t)=>{if(!e.connected)throw Error("Wallet is not connected.");return await e.signMessage(t[0])}),"sendTransaction"in e&&(i=async(...t)=>await e.sendTransaction(t[0],t[1],t[2])),"signTransaction"in e&&(a=async t=>await e.signTransaction(t)),{type:"solana",address:e.publicKey.toBase58(),meta:n,imported:!1,connectedAt:Date.now(),walletClientType:this.walletClientType,connectorType:this.connectorType,isConnected:async()=>e.connected,disconnect:()=>{try{e.disconnect()}catch(t){console.error("Wallet does not support programmatic disconnect")}},getProvider:t(`${this.walletClientType||""} wallet does not support 'getProvider'`),signMessage:s??t(`${this.walletClientType||""} wallet does not support 'signMessage'`),sendTransaction:i??t(`${this.walletClientType||""} wallet does not support 'sendTransaction'`),signTransaction:a??t(`${this.walletClientType||""} wallet does not support 'signTransaction'`)}}async syncAccounts(){if("Installed"===this.adapter.readyState&&this.adapter.publicKey){let t={name:this.walletBranding.name,icon:"string"==typeof this.walletBranding.icon?this.walletBranding.icon:void 0,id:this.walletBranding.id};this.wallets.find((t=>this.adapter.publicKey&&t.address===this.adapter.publicKey.toBase58()))||(this.wallets=[this.buildConnectedWallet(this.adapter,t)],this.emit("walletsUpdated"))}else this.wallets.length>0&&(this.wallets=[],this.emit("walletsUpdated"))}get walletBranding(){return{id:this.adapter.name,name:this.adapter.name,icon:this.adapter.icon}}async initialize(){this.subscribeListeners(),await this.syncAccounts(),this.shouldAutoConnect&&await this.adapter.autoConnect().catch(console.error),this.initialized=!0,this.emit("initialized")}async connect(t){return t.showPrompt&&await this.promptConnection(),await this.isConnected()?this.getConnectedWallet():null}async getConnectedWallet(){return this.wallets.sort(((t,e)=>e.connectedAt-t.connectedAt))[0]||null}async isConnected(){return this.adapter.connected&&["Installed"].includes(this.adapter.readyState)}subscribeListeners(){this.adapter.addListener("disconnect",this.onDisconnect),this.adapter.addListener("connect",this.onConnect),this.adapter.addListener("error",this.onError),this.adapter.addListener("readyStateChange",this.onReadyStateChange)}unsubscribeListeners(){this.adapter.removeAllListeners()}constructor(t,n){super(e(t.name.toLowerCase())?t.name.toLowerCase():"unknown"),this.chainType="solana",this.connectorType="solana_adapter",this.disconnect=()=>{this.adapter.disconnect().then((()=>this.onDisconnect())).catch((t=>console.error("Error disconnecting",t)))},this.promptConnection=async()=>{try{await this.adapter.connect()}catch(t){throw s(t)}},this.onDisconnect=()=>{this.syncAccounts()},this.onConnect=t=>{this.syncAccounts()},this.onError=t=>{this.syncAccounts()},this.onReadyStateChange=t=>{"Installed"!==t&&(this.connected=!1),this.syncAccounts()},this.adapter=t,this.shouldAutoConnect=n,this.wallets=[]}}export{o as SolanaWalletConnector,a as isBaseConnectedSolanaWallet,i as isSolanaWalletConnector};
