import{getAddress as e}from"@ethersproject/address";import{Web3Provider as t}from"@ethersproject/providers";import{getPrivyWalletKey as i,DEFAULT_NETWORK as n}from"../../constants.mjs";import{PrivyConnectorError as r}from"../../errors.mjs";import s from"../../storage.mjs";import{formatChainIdToCAIP2 as o,invokeUntilSettled as a}from"../../utils/index.mjs";import{areWalletArraysEqual as c}from"../areWalletArraysEqual.mjs";import{WalletConnector as h}from"../base.mjs";import{getRpcTimeout as d}from"../getRpcTimeout.mjs";import{AsExternalProvider as l,AsAbstractProvider as p}from"../privyProxyProvider.mjs";import"ofetch";import"../get-legacy-injected-providers.mjs";import"../is-wallet-installed.mjs";import"../isBaseConnectedEthereumWallet.mjs";import"eventemitter3";import"../errors.mjs";import"@ethersproject/logger";import"@privy-io/js-sdk-core";function m(e){return"ethereum"===e.chainType}class u extends h{buildConnectedWallet(i,n,s,a){let c=async()=>!!this.wallets.find((t=>e(t.address)===e(i)));return{type:"ethereum",address:e(i),chainId:n,meta:s,imported:a,switchChain:async t=>{let s,a;if(!c)throw new r("Wallet is not currently connected.");let h=this.wallets.find((t=>e(t.address)===e(i)))?.chainId;if(!h)throw new r("Unable to determine current chainId.");if("number"==typeof t?(s=`0x${t.toString(16)}`,a=t):(s=t,a=Number(t)),h===o(s))return;let d=this.chains.find((e=>e.id===a));if(!d)throw new r(`Unsupported chainId: ${t}`);let l=async()=>{await this.proxyProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:s}]})};try{return await l()}catch(e){if(((e,t)=>"coinbase_wallet"===t?e.message.includes("addEthereumChain"):4902===e.code||e.message?.includes("4902"))(e,this.walletClientType))return await this.proxyProvider.request({method:"wallet_addEthereumChain",params:[{chainId:s,chainName:d.name,nativeCurrency:d.nativeCurrency,rpcUrls:[d.rpcUrls.default?.http[0]??""],blockExplorerUrls:[d.blockExplorers?.default.url??""]}]}),l();if("rainbow"===this.walletClientType&&e.message?.includes("wallet_switchEthereumChain"))throw new r(`Rainbow does not support the chainId ${n}`);throw e}},connectedAt:Date.now(),walletClientType:this.walletClientType,connectorType:this.connectorType,isConnected:c,getEthereumProvider:async()=>{if(!await c())throw new r("Wallet is not currently connected.");return this.proxyProvider},getEthersProvider:async()=>{if(!await c())throw new r("Wallet is not currently connected.");return new t(new l(this.proxyProvider))},getWeb3jsProvider:async()=>{if(!await c())throw new r("Wallet is not currently connected.");return new p(this.proxyProvider)},sign:async e=>{if(!await c())throw new r("Wallet is not currently connected.");return await this.sign(e)},disconnect:()=>{this.disconnect()}}}async syncAccounts(t){let r,h=t;try{if(void 0===h){let e=await a((()=>this.proxyProvider.request({method:"eth_accounts"})),{maxAttempts:10,delayMs:500});console.debug(`eth_accounts for ${this.walletClientType}:`,e),Array.isArray(e)&&(h=e)}}catch(e){console.debug("Wallet did not respond to eth_accounts. Defaulting to prefetched accounts.",e)}if(!h||!Array.isArray(h)||h.length<=0||!h[0])return;let d=h[0],l=e(d),p=[];if("privy"===this.walletClientType){let e=s.get(i(l));this.chains.find((t=>t.id===Number(e)))||(s.del(i(l)),e=null),r=e||`0x${this.defaultChain.id.toString(16)}`;try{await this.proxyProvider.request({method:"wallet_switchEthereumChain",params:[{chainId:r}]})}catch(e){console.warn(`Unable to switch embedded wallet to chain ID ${r} on initialization`)}}else try{let e=await a((()=>this.proxyProvider.request({method:"eth_chainId"})),{maxAttempts:10,delayMs:500});if(console.debug(`eth_chainId for ${this.walletClientType}:`,e),"string"==typeof e)r=e;else{if("number"!=typeof e)throw Error("Invalid chainId returned from provider");r=`0x${e.toString(16)}`}}catch(e){console.warn(`Failed to get chainId from provider, defaulting to ${n}`,e),r=n}let m=o(r);if(!p.find((t=>e(t.address)===l))){let t={name:this.walletBranding.name,icon:"string"==typeof this.walletBranding.icon?this.walletBranding.icon:void 0,id:this.walletBranding.id};p.push(this.buildConnectedWallet(e(d),m,t,"embedded_imported"===this.connectorType))}c(p,this.wallets)||(this.wallets=p,this.emit("walletsUpdated"))}async getConnectedWallet(){let t=await this.proxyProvider.request({method:"eth_accounts"});return this.wallets.sort(((e,t)=>t.connectedAt-e.connectedAt)).find((i=>t.find((t=>e(t)===e(i.address)))))||null}async isConnected(){let e=await this.proxyProvider.request({method:"eth_accounts"});return Array.isArray(e)&&e.length>0}async sign(e){return await this.connect({showPrompt:!1}),new t(new l(this.proxyProvider)).getSigner().signMessage(e)}subscribeListeners(){this.proxyProvider.on("accountsChanged",this.onAccountsChanged),this.proxyProvider.on("chainChanged",this.onChainChanged),this.proxyProvider.on("disconnect",this.onDisconnect),this.proxyProvider.on("connect",this.onConnect)}unsubscribeListeners(){this.proxyProvider.removeListener("accountsChanged",this.onAccountsChanged),this.proxyProvider.removeListener("chainChanged",this.onChainChanged),this.proxyProvider.removeListener("disconnect",this.onDisconnect),this.proxyProvider.removeListener("connect",this.onConnect)}constructor(e,t,n,r){super(e),this.chainType="ethereum",this.onAccountsChanged=e=>{0===e.length?this.onDisconnect():this.syncAccounts(e)},this.onChainChanged=e=>{this.wallets.forEach((t=>{t.chainId=o(e),"privy"===this.walletClientType&&s.put(i(t.address),e)})),this.emit("walletsUpdated")},this.onDisconnect=()=>{this.connected=!1,this.wallets=[],this.emit("walletsUpdated")},this.onConnect=()=>{this.connected=!0,this.syncAccounts()},this.wallets=[],this.walletClientType=e,this.chains=t,this.defaultChain=n,this.rpcConfig=r,this.rpcTimeoutDuration=d(r,e),this.connected=!1,this.initialized=!1}}export{u as EthereumWalletConnector,m as isEthereumWalletConnector};
