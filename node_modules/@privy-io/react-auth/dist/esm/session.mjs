import e from"js-cookie";import{authFlowToAuthenticateMethod as t}from"./auth-flows/authFlowToAuthenticateMethod.mjs";import{convertUserResponseToUser as s}from"./client/user.mjs";import{CUSTOMER_ACCESS_TOKEN_STORAGE_KEY as r,PRIVY_ACCESS_TOKEN_STORAGE_KEY as o,REFRESH_TOKEN_STORAGE_KEY as n,FORKED_TOKEN_STORAGE_KEY as i,getProviderAccessTokenStorageKey as c,SESSION_COOKIE_KEY as a,DEPRECATED_REFRESH_TOKEN as h,CUSTOMER_ACCESS_TOKEN_COOKIE_KEY as l,REFRESH_TOKEN_COOKIE_KEY as k,IDENTITY_TOKEN_STORAGE_KEY as u,IDENTITY_TOKEN_COOKIE_KEY as p}from"./constants.mjs";import{getSecureMode as d}from"./cookies.mjs";import{RunEffectOnce as f}from"./effect.mjs";import{formatPrivyError as m,PrivyClientError as _,PrivyApiError as y,PrivyErrorCode as T}from"./errors.mjs";import{sessionsRefreshPath as w,recoverForkedSessionsPath as v,sessionsLogoutPath as g,forkSessionPath as S}from"./paths.mjs";import A from"./storage.mjs";import{Token as j}from"./token.mjs";import"./auth-flows/custom-jwt-account.mjs";import"./auth-flows/email.mjs";import"./auth-flows/getUiHeader.mjs";import"./auth-flows/guest.mjs";import"jose";import"./crypto.mjs";import"./auth-flows/siwe.mjs";import"./lib/siwe.mjs";import"ofetch";import"./auth-flows/sms.mjs";import"./auth-flows/oauth/OAuthFlow.mjs";import"./lib/pkce.mjs";import"@ethersproject/address";import"react-device-detect";var C,x=((C={}).PRIVY="privy_access_token",C.CUSTOMER="customer_access_token",C);class I{get token(){return this.privyAccessToken||this.customerAccessToken}getToken(e){return"privy_access_token"===e?this.privyAccessToken:this.customerAccessToken}get customerAccessToken(){return this._getToken(r)}get privyAccessToken(){return this._getToken(o)}_getToken(e){try{let t=A.get(e);return"string"==typeof t?j.throwIfNotWellFormedJwt(t):null}catch(e){return console.error(e),this.destroyLocalState(),null}}get refreshToken(){try{let e=A.get(n);return"string"==typeof e?e:null}catch(e){return console.error(e),this.destroyLocalState(),null}}get forkedToken(){try{let e=A.get(i);return"string"==typeof e?e:null}catch(e){return console.error(e),this.destroyLocalState(),null}}getProviderAccessToken(e){try{let t=A.get(c(e));if("string"!=typeof t)return null;{let s=new j(t);return s.isExpired()?(A.del(c(e)),null):s.value}}catch(e){return console.error(e),null}}get mightHaveServerCookies(){try{let t=e.get(a);return void 0!==t&&t.length>0}catch(e){console.error(e)}return!1}hasRefreshCredentials(e="privy_access_token"){let t="string"==typeof this.getToken(e),s="string"==typeof this.refreshToken&&this.refreshToken!==h;return this.mightHaveServerCookies||t&&s}hasRecoveryCredentials(){return"string"==typeof this.forkedToken}hasActiveAccessToken(e){let t=j.parse(this.getToken(e));return null!==t&&!t.isExpired(30)}authenticate(e){return this.authenticateOnce.execute(e)}link(e){return this.linkOnce.execute(e)}refresh(){return this.refreshOnce.execute()}forkSession(){return this.forkSessionOnce.execute()}destroy(){return this.destroyOnce.execute()}storeProviderAccessToken(e,t){"string"==typeof t?A.put(c(e),t):A.del(c(e))}async _authenticate(e){try{let t=await e.authenticate(),{user:r,is_new_user:o,oauth_tokens:n}=t;this.handleTokenResponse(t);let i=n?{provider:n.provider,accessToken:n.access_token,accessTokenExpiresInSeconds:n.access_token_expires_in_seconds,refreshToken:n.refresh_token,refreshTokenExpiresInSeconds:n.refresh_token_expires_in_seconds,scopes:n.scopes}:void 0;return this._trackAuthenticateEvents(e,o),{user:s(r),isNewUser:o,oAuthTokens:i}}catch(e){throw console.warn("Error authenticating session"),m(e)}}_trackAuthenticateEvents(e,s){let r=t(e);r&&this.client&&this.client.createAnalyticsEvent({eventName:"sdk_authenticate",payload:{method:r,isNewUser:s}}),"siwe"===r&&this.client&&this.client.createAnalyticsEvent({eventName:"sdk_authenticate_siwe",payload:{connectorType:e.meta.connectorType,walletClientType:e.meta.walletClientType}})}async _link(e){try{let t=await e.link(),r=t.oauth_tokens,o=r?{provider:r.provider,accessToken:r.access_token,accessTokenExpiresInSeconds:r.access_token_expires_in_seconds,refreshToken:r.refresh_token,refreshTokenExpiresInSeconds:r.refresh_token_expires_in_seconds,scopes:r.scopes}:void 0;return{user:s(t),oAuthTokens:o}}catch(e){throw console.warn("Error linking account"),m(e)}}async _refresh(){if(!this.api)throw new _("Session has no API instance");if(!this.client)throw new _("Session has no PrivyClient instance");await this.client.getAccessToken({disableAutoRefresh:!0});let e=this.token,t=this.refreshToken,r=this.forkedToken;if(this.client.useServerCookies&&!this.mightHaveServerCookies&&this.token&&window.location.origin===this.client.apiUrl)return this.destroyLocalState(),null;try{let o;if(e&&t||this.mightHaveServerCookies){let s={};e&&(s.authorization=`Bearer ${e}`),o=await this.api.post(w,t?{refresh_token:t}:{},{headers:s}),r&&this.clearForkedToken()}else{if(!r)return null;o=await this.api.post(v,{refresh_token:r}),this.clearForkedToken()}return this.handleTokenResponse(o),s(o.user)}catch(e){if(e instanceof y&&e.privyErrorCode===T.MISSING_OR_INVALID_TOKEN)return console.warn("Unable to refresh tokens - token is missing or no longer valid"),this.destroyLocalState(),null;throw m(e)}}handleTokenResponse(e){e.session_update_action&&"set"!==e.session_update_action?"clear"===e.session_update_action?this.destroyLocalState():"ignore"===e.session_update_action&&(e.token&&(this.storeCustomerAccessToken(e.token),this.storePrivyAccessToken(e.privy_access_token)),e.identity_token&&this.storeIdentityToken(e.identity_token)):this._storeAllTokens(e)}_storeAllTokens(e){this.storeRefreshToken(e.refresh_token),this.storeCustomerAccessToken(e.token),this.storePrivyAccessToken(e.privy_access_token),e.identity_token&&this.storeIdentityToken(e.identity_token)}async _destroy(){try{await(this.api?.post(g,{refresh_token:this.refreshToken}))}catch(e){console.warn("Error destroying session")}this.destroyLocalState()}async _forkSession(){if(!this.api)throw new _("Session has no API instance");let e=this.refreshToken;try{let t=await this.api.post(S,{refresh_token:e});return this.storeRefreshToken(t.refresh_token),this.storeCustomerAccessToken(t.token),t.new_session_refresh_token}catch(e){throw m(e)}}destroyLocalState(){this.storeRefreshToken(null),this.storeCustomerAccessToken(null),this.storePrivyAccessToken(null),this.clearIdentityToken(),this.clearForkedToken()}storeCustomerAccessToken(t){if("string"==typeof t){let s=A.get(r);if(A.put(r,t),!this.client?.useServerCookies){let s=j.parse(t)?.expiration;e.set(l,t,{sameSite:"Strict",secure:d(),expires:s?new Date(1e3*s):void 0})}s!==t&&this.client?.onStoreCustomerAccessToken?.(t)}else A.del(r),e.remove(l),this.client?.onDeleteCustomerAccessToken?.()}storeRefreshToken(t){"string"==typeof t?(A.put(n,t),this.client?.useServerCookies||e.set(a,"t",{sameSite:"Strict",secure:d(),expires:30})):(A.del(n),e.remove(k),e.remove(a))}storePrivyAccessToken(e){"string"==typeof e?A.put(o,e):A.del(o)}storeIdentityToken(t){if(this.client?.useServerCookies)return;A.put(u,t);let s=j.parse(t)?.expiration;e.set(p,t,{sameSite:"Strict",secure:d(),expires:s?new Date(1e3*s):void 0})}clearIdentityToken(){A.del(u),e.remove(p)}clearForkedToken(){A.del(i)}constructor(){this.authenticateOnce=new f((async e=>this._authenticate(e))),this.linkOnce=new f((async e=>this._link(e))),this.refreshOnce=new f(this._refresh.bind(this)),this.destroyOnce=new f(this._destroy.bind(this)),this.forkSessionOnce=new f(this._forkSession.bind(this))}}export{x as AccessTokenTypes,I as Session};
