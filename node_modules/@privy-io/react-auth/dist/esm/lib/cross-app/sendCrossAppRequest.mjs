import{toHex as e}from"viem";import{PrivyClientError as r}from"../../errors.mjs";import{triggerPopup as t}from"../popup/triggerPopup.mjs";import{getProviderAppMetadata as a}from"./authFlow.mjs";import"ofetch";import"../../auth-flows/cross-app.mjs";import"../../paths.mjs";import"../pkce.mjs";import"jose";import"../../constants.mjs";import"../../crypto.mjs";import"../../storage.mjs";const s=async({user:e,address:s,client:n,request:i,requesterAppId:d,reconnect:p})=>{n.createAnalyticsEvent({eventName:"cross_app_request_started",payload:{address:s,method:i.method}});let c=e?.linkedAccounts.find((e=>"cross_app"===e.type&&(e.embeddedWallets.some((e=>e.address===s))||e.smartWallets.some((e=>e.address===s)))));if(!e||!c)throw n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Cannot request a signature with this wallet address",address:s}}),new r("Cannot request a signature with this wallet address");let l=n.getProviderAccessToken(c.providerApp.id),m=await a({api:n.api,requesterAppId:d,providerAppId:c.providerApp.id});if(!l){if(m.readOnly)throw console.error("cannot transact against a read-only provider app"),new r("Cannot transact against a read-only provider app");await p({appId:c.providerApp.id,action:"link"})&&(l=n.getProviderAccessToken(c.providerApp.id))}if(!l)throw n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Transactions require a valid token",address:s}}),new r("Transactions require a valid token");let u=t();if(!u)throw n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Missing token",address:s}}),new r("Failed to initialize signature request");let v=new URL(`${m.apiUrl}/oauth/transact`);return v.searchParams.set("token",l||""),v.searchParams.set("request",o(i)),u.location=v.href,new Promise(((e,t)=>{let a=setTimeout((()=>{p(),t(new r("Request timeout")),n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"Request timeout",address:s}})}),12e4),o=setInterval((()=>{u.closed&&(p(),t(new r("User rejected request")),n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:"User rejected request",address:s}}))}),300),d=r=>{r.data&&("set"===r.data.token?.action&&void 0!==r.data.token?.value?n.storeProviderAccessToken(c.providerApp.id,r.data.token.value):"clear"===r.data.token?.action&&n.storeProviderAccessToken(c.providerApp.id,null),"PRIVY_CROSS_APP_ACTION_RESPONSE"===r.data.type&&r.data.result&&(p(),e(r.data.result),n.createAnalyticsEvent({eventName:"cross_app_request_success",payload:{address:s,method:i.method}})),"PRIVY_CROSS_APP_ACTION_ERROR"===r.data.type&&r.data.error&&(p(),t(r.data.error),n.createAnalyticsEvent({eventName:"cross_app_request_error",payload:{error:r.data.error,address:s}})))};window.addEventListener("message",d);let p=()=>{u.close(),clearInterval(o),clearTimeout(a),window.removeEventListener("message",d)}}))};let o=r=>JSON.stringify({content:{request:{request:n(r,e)}},timestamp:Date.now(),callbackUrl:window.origin});const n=(e,r)=>"bigint"==typeof e?r(e):Array.isArray(e)?e.map((e=>n(e,r))):e&&"object"==typeof e?Object.fromEntries(Object.entries(e).map((([e,t])=>[e,n(t,r)]))):e;export{n as replaceBigInts,s as sendCrossAppRequest};
