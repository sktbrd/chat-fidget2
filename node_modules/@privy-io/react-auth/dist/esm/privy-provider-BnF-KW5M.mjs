import{jsx as e,jsxs as t}from"react/jsx-runtime";import{getAddress as r}from"@ethersproject/address";import{Web3Provider as a}from"@ethersproject/providers";import{createStore as n}from"mipd";import{useState as i,useRef as o,useEffect as s,useMemo as l}from"react";import{isAndroid as c}from"react-device-detect";import{populateTransactionRequest as d,calculateTotalGasEstimate as u,ProviderErrors as h}from"@privy-io/js-sdk-core";import{CustomJwtAccountFlow as p}from"./auth-flows/custom-jwt-account.mjs";import{UpdateEmailFlow as w,EmailFlow as m}from"./auth-flows/email.mjs";import{FarcasterFlow as y}from"./auth-flows/farcaster.mjs";import{GuestFlow as f}from"./auth-flows/guest.mjs";import{PasskeyFlow as g}from"./auth-flows/passkey.mjs";import{SiweFlow as E}from"./auth-flows/siwe.mjs";import{SiwsFlow as _}from"./auth-flows/siws.mjs";import{UpdateSmsFlow as A,SmsFlow as T}from"./auth-flows/sms.mjs";import{TelegramAuthFlow as v,detectCompletingTelegramFlow as C}from"./auth-flows/telegram.mjs";import{v4 as I}from"uuid";import{AccessToken as W}from"./accessToken.mjs";import{getEntropyDetailsFromAccount as k,convertUserResponseToUser as N,getPrivySolanaHDWallets as b,getImportedPrivySolanaWallet as U,getPrivyPrimaryWallet as O,getPrivyEthereumWallet as S,getPrivyEthereumHDWallets as R,getImportedPrivyEthereumWallet as P,shouldProceedtoEmbeddedWalletCreationFlow as D,getPrivySolanaWallet as L,getLatestPrivyEthereumWallet as M,getSolanaSigningAndRootWallet as F,getEthereumSigningAndRootWallet as x,getLatestPrivySolanaWallet as j,getEntropyDetailsFromUser as B}from"./client/user.mjs";import V from"eventemitter3";import{CONNECTORS_STATE_KEY as H,CONNECTIONS_HISTORY_KEY as K,DEFAULT_PRIVY_API_URL as G,DEFAULT_API_TIMEOUT_MS as z,CLIENT_ANALYTICS_ID_KEY as q,CUSTOMER_ACCESS_TOKEN_STORAGE_KEY as $,PRIVY_ACCESS_TOKEN_STORAGE_KEY as Y,getGuestCredentialStorageKey as X,HEADLESS_OAUTH_KEY as Q,OAUTH_DISABLE_SIGNUP_KEY as J,STATE_CODE_KEY as Z,WALLET_PROXY_TIMEOUT as ee,FORKED_TOKEN_STORAGE_KEY as te}from"./constants.mjs";import re,{isLocalStorageAccessible as ae}from"./storage.mjs";import{getJsonRpcProvider as ne,generateTypedDataWithDomainType as ie,toHex as oe,detectInjectedConnectors as se,formatChainIdToCAIP2 as le}from"./utils/index.mjs";import{CoinbaseWalletConnector as ce}from"./connectors/coinbase.mjs";import{EmbeddedWalletConnector as de}from"./connectors/embedded.mjs";import{isSupportedEthereumRpcMethod as ue}from"./embedded-wallets/rpc/types.mjs";import{Captcha as he}from"./components/Captcha.mjs";import{LoginModal as pe}from"./components/LoginModal.mjs";import{TelegramLoginButton as we}from"./components/TelegramLoginButton.mjs";import{PrivyAppConfigProvider as me,useAppConfig as ye,useIsServerConfigLoaded as fe}from"./configuration/context.mjs";import{areWalletArraysEqual as ge}from"./connectors/areWalletArraysEqual.mjs";import{PrivyProviderRpcError as Ee,ProviderRpcError as _e}from"./connectors/errors.mjs";import{isPhantomInstalled as Ae}from"./connectors/is-wallet-installed.mjs";import{isBaseConnectedEthereumWallet as Te}from"./connectors/isBaseConnectedEthereumWallet.mjs";import{PrivyProxyProvider as ve,AsExternalProvider as Ce,AsAbstractProvider as Ie}from"./connectors/privyProxyProvider.mjs";import{isSolanaWalletConnector as We,isBaseConnectedSolanaWallet as ke}from"./connectors/solana/index.mjs";import{WalletConnectV2WalletConnector as Ne}from"./connectors/walletconnect-v2.mjs";import{EmbeddedWalletIframe as be}from"./embedded-wallets/EmbeddedWalletIframe.mjs";import{isWalletDelegated as Ue,getDelegatedWalletsData as Oe,getRootWalletDataForDelegation as Se,getDelegatedWalletsForUser as Re}from"./embedded-wallets/delegated-actions.mjs";import{errorIndicatesRecoveryIsNeeded as Pe}from"./embedded-wallets/errors.mjs";import{formatReceipt as De,getAndCheckBalance as Le,sendTransaction as Me}from"./embedded-wallets/rpc/index.mjs";import{PrivyClientError as Fe,formatApiError as xe,formatPrivyError as je,PrivyErrorCode as Be,PrivyNotReadyError as Ve,PrivyConnectorError as He,PrivyError as Ke}from"./errors.mjs";import{signSolanaTransaction as Ge,sendSolanaTransaction as ze}from"./embedded-wallets/solana/transaction.mjs";import{extractChainIdFromCAIP2 as qe}from"./lib/caip2.mjs";import{USE_BROADCAST_CHANNEL_EVENT_TYPE as $e,isPrivyTheOAuthProvider as Ye,CROSS_APP_BROADCAST_CHANNEL_NAME as Xe}from"./lib/cross-app/index.mjs";import{getCrossAppAuthorizationUrl as Qe,authenticateCrossAppAccount as Je,getProviderAppMetadata as Ze}from"./lib/cross-app/authFlow.mjs";import{popupCrossAppAuthFlow as et}from"./lib/cross-app/popupCrossAppAuthFlow.mjs";import{sendCrossAppRequest as tt}from"./lib/cross-app/sendCrossAppRequest.mjs";import{getRecoveryAuthorizationUrl as rt,authenticateRecovery as at,embeddedWalletRecoveryScreen as nt,toEmbeddedWalletSetRecoveryScreen as it}from"./lib/embeddedWalletRecovery.mjs";import{FUNDING_SCREENS as ot,fundingScreenMethodMap as st}from"./lib/funding/index.mjs";import{isFundingEnabled as lt}from"./lib/funding/isFundingEnabled.mjs";import ct from"./lib/isEmbeddedWebview.mjs";import{triggerPopup as dt}from"./lib/popup/triggerPopup.mjs";import{popupOAuthFlow as ut}from"./lib/popupOAuthFlow.mjs";import{prepareSiweMessageWithNonce as ht}from"./lib/siwe.mjs";import{decodeSolanaTransaction as pt,createSolanaTransactionReceipt as wt}from"./lib/solana/transaction.mjs";import{toDisplayFromAccountType as mt}from"./lib/toDisplayFromAccountType.mjs";import{transformResponseToSnakeCase as yt}from"./passkeys/transformResponseToSnakeCase.mjs";import{PrivyPluginProvider as ft,usePlugins as gt}from"./plugins/context/PrivyPluginContext.mjs";import{SOLANA_FUNDING_PLUGIN_ID as Et}from"./plugins/solana-funding/id.mjs";import{RecentlyUsedAccountProvider as _t}from"./recent-login/context.mjs";import{ModalScreen as At}from"./screens/index.mjs";import{Hide as Tt}from"./screens/LandingScreen/styles.mjs";import{GlobalStyle as vt}from"./styles.mjs";import{notImplemented as Ct}from"./hooks/index.mjs";import{CaptchaProvider as It}from"./hooks/captcha-context.mjs";import{privyEventsDefault as Wt,emitPrivyEvent as kt,PrivyEventsContext as Nt}from"./hooks/events-context.mjs";import{InternalPrivyContext as bt}from"./hooks/internal-context.mjs";import{ModalProvider as Ut}from"./hooks/modal-context.mjs";import{PrivyContext as Ot}from"./hooks/privy-context.mjs";import{UseWalletsContext as St}from"./hooks/useWallets.mjs";import{prepareSolanaFundingModalData as Rt,prepareFundingModalData as Pt}from"./lib/funding/prepareFundingModalData.mjs";import{detectCompletingOAuthFlow as Dt}from"./auth-flows/oauth/detectCompletingOAuthFlow.mjs";import{OAuthFlow as Lt}from"./auth-flows/oauth/OAuthFlow.mjs";import{getRpcTimeout as Mt}from"./connectors/getRpcTimeout.mjs";import{EmbeddedProviderError as Ft}from"./connectors/providerTypes.mjs";import{isEthereumWalletConnector as xt}from"./connectors/ethereum/index.mjs";import{LegacyInjectedWalletConnector as jt,Injected6963WalletConnector as Bt}from"./connectors/injected.mjs";import{MetamaskWalletConnector as Vt}from"./connectors/metamask.mjs";import{PhantomEthereumNullWalletConnector as Ht}from"./connectors/phantom.mjs";import{PhantomSolanaNullWalletConnector as Kt}from"./connectors/phantom-solana.mjs";import{Http as Gt}from"./http.mjs";import{getPaymasterContext as zt}from"./lib/smart-wallet-helpers.mjs";import{transformOptionsToCamelCase as qt}from"./passkeys/transformOptionsToCamelCase.mjs";import{mfaPasswordlessSmsInitPath as $t,mfaPasskeyInitPath as Yt,acceptTermsPath as Xt,unlinkEmailPath as Qt,unlinkPhonePath as Jt,unlinkWalletPath as Zt,siwsUnlinkWalletPath as er,unlinkOAuthPath as tr,unlinkFarcasterPath as rr,telegramAccountUnlinkPath as ar,unlinkPasskeyPath as nr,delegatedActionsRevokePath as ir,analyticsEventsPath as or,moonpayPluginOnRampPath as sr,coinbaseOnRampInitPath as lr,coinbaseOnRampStatusPath as cr,siweInitPath as dr,siweAuthenticatePath as ur,siweLinkPath as hr,smartWalletLinkPath as pr,siwsInitPath as wr,siwsAuthenticatePath as mr,transferOAuthPath as yr,telegramAccountTransferPath as fr,transferFarcasterPath as gr,transferWalletPath as Er,transferPhonePath as _r,transferEmailPath as Ar,siwsLinkPath as Tr}from"./paths.mjs";import{AccessTokenTypes as vr,Session as Cr}from"./session.mjs";class Ir extends V{async handleSendTransaction(e){if(!e.params||!Array.isArray(e.params))throw new Ft(`Invalid params for ${e.method}`,4200);let t=e.params[0];if(!await Vr()||!this.address)throw new Ft("Disconnected",4900);return(await Gr(t,void 0,void 0,this.address)).hash}handleSwitchEthereumChain(e){let t;if(!e.params||!Array.isArray(e.params))throw new Ft(`Invalid params for ${e.method}`,4200);if("string"==typeof e.params[0])t=e.params[0];else{if(!("chainId"in e.params[0])||"string"!=typeof e.params[0].chainId)throw new Ft(`Invalid params for ${e.method}`,4200);t=e.params[0].chainId}this.chainId=Number(t),this.provider=ne(this.chainId,this.chains,this.rpcConfig,{appId:this.appId}),this.emit("chainChanged",t)}async handlePersonalSign(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for personal_sign");let t=e.params[0],r=e.params[1];return await Hr(t,void 0,r)}async handleSignedTypedData(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_signTypedData_v4");let t=e.params[0],r="string"==typeof e.params[1]?JSON.parse(e.params[1]):e.params[1];return await Kr(ie(r),void 0,t)}async handleEstimateGas(e){if(!e.params||!Array.isArray(e.params))throw Error("Invalid params for eth_estimateGas");delete e.params[0].gasPrice,delete e.params[0].maxFeePerGas,delete e.params[0].maxPriorityFeePerGas;let t={...e.params[0],chainId:oe(this.chainId)};try{return await this.provider.send("eth_estimateGas",[t])}catch(e){console.warn(`Gas estimation failed with error: ${e}. Retrying gas estimation by omitting the 'from' address`);try{return delete t.from,await this.provider.send("eth_estimateGas",[t])}catch(t){throw console.warn(`Gas estimation failed with error: ${t} when omitting the 'from' address`),e}}}async request(e){switch(console.debug("Embedded1193Provider.request() called with args",e),e.method){case"eth_accounts":case"eth_requestAccounts":return this.address?[this.address]:[];case"eth_chainId":return oe(this.chainId);case"eth_estimateGas":return this.handleEstimateGas(e);case"eth_sendTransaction":return this.handleSendTransaction(e);case"wallet_switchEthereumChain":return this.handleSwitchEthereumChain(e);case"personal_sign":return this.handlePersonalSign(e);case"eth_signTypedData_v4":return this.handleSignedTypedData(e)}if(!ue(e.method))return this.provider.send(e.method,e.params);{let t=await Vr();if(await zr(),!t||!this.address)throw new Ft("Disconnected",4900);try{return(await this.walletProxy.rpc({accessToken:t,entropyId:this.entropyId,entropyIdVerifier:this.entropyIdVerifier,chainType:"ethereum",hdWalletIndex:this.walletIndex,request:{method:e.method,params:e.params}})).response.data}catch(e){throw console.error(e),new Ft("Disconnected",4900)}}}constructor({walletProxy:e,address:t,entropyId:r,entropyIdVerifier:a,rpcConfig:n,chains:i,appId:o,chainId:s=1,walletIndex:l}){super(),this.walletProxy=e,this.address=t,this.entropyId=r,this.entropyIdVerifier=a,this.chainId=s,this.rpcConfig=n,this.chains=i,this.provider=ne(s,this.chains,n,{appId:o}),this.rpcTimeoutDuration=Mt(n,"privy"),this.appId=o,this.walletIndex=l}}class Wr extends V{get wallets(){let e=new Set,t=this.walletConnectors.flatMap((e=>e.wallets)).sort(((e,t)=>e.connectedAt&&t.connectedAt?t.connectedAt-e.connectedAt:0)).filter((t=>{let r=`${t.address}${t.walletClientType}${t.connectorType}`;return!e.has(r)&&(e.add(r),!0)})),r=t.findIndex((e=>e.address===(this.activeWallet?this.activeWallet:"unknown")));return r>=0&&t.unshift(t.splice(r,1)[0]),t}async initialize(){if(this.initialized)return;re.get(H)&&(re.getKeys().forEach((e=>{e.startsWith("walletconnect")&&re.del(e)})),re.del(H));let e=se({store:this.store,walletList:this.walletList,externalWalletConfig:this.externalWalletConfig,walletChainType:this.walletChainType}).then((e=>{e.forEach((({type:e,eip6963InjectedProvider:t,legacyInjectedProvider:r})=>{this.createEthereumWalletConnector("injected",e,{eip6963InjectedProvider:t,legacyInjectedProvider:r})}))}));this.walletList.includes("coinbase_wallet")&&this.createEthereumWalletConnector("coinbase_wallet","coinbase_wallet"),!Ae()&&this.walletList.includes("phantom")&&(["ethereum-only","ethereum-and-solana"].includes(this.walletChainType)&&this.createEthereumWalletConnector("phantom","phantom"),["ethereum-and-solana","solana-only"].includes(this.walletChainType)&&this.addWalletConnector(new Kt)),this.externalWalletConfig.walletConnect.enabled&&this.createEthereumWalletConnector("wallet_connect_v2","unknown"),this.externalWalletConfig.solana.connectors?.get().forEach(this.addSolanaWalletConnector),this.externalWalletConfig.solana.connectors?._setOnConnectorsUpdated?.((e=>{e?.forEach(this.addSolanaWalletConnector)})),await e,this.initialized=!0}findWalletConnector(e,t){return"wallet_connect_v2"===e?this.walletConnectors.filter(xt).find((t=>t.connectorType===e))??null:this.walletConnectors.filter(xt).find((r=>r.connectorType===e&&r.walletClientType===t))??null}findSolanaWalletConnector(e,t){return this.walletConnectors.filter(We).find((r=>r.connectorType===e&&r.walletClientType===t))??null}findEmbeddedWalletConnectors(){return this.walletConnectors.filter((e=>"embedded"===e.connectorType))}onInitialized(e){e.wallets.forEach((e=>{let t=this.storedConnections.find((t=>t.address===e.address&&t.connectorType===e.connectorType&&t.walletClientType===e.walletClientType));t&&(e.connectedAt=t.connectedAt)})),this.saveConnectionHistory(),this.emit("walletsUpdated"),this.emit("connectorInitialized")}onWalletsUpdated(e){e.initialized&&(this.saveConnectionHistory(),this.emit("walletsUpdated"))}addEmbeddedWalletConnectors({walletProxy:e,rootWallet:t,embeddedWallets:r,defaultChain:a,appId:n}){for(let i of r){let r=this.findEmbeddedWalletConnectors().find((e=>e.walletIndex===i.walletIndex));if(r&&xt(r))r.proxyProvider.walletProxy=e;else{let{entropyId:r,entropyIdVerifier:o}=k(t),s=new de({provider:new Ir({walletProxy:e,address:i.address,entropyId:r,entropyIdVerifier:o,rpcConfig:this.rpcConfig,chains:this.chains,appId:n,chainId:a.id,walletIndex:i.walletIndex}),chains:this.chains,defaultChain:a,rpcConfig:this.rpcConfig,imported:!1,walletIndex:i.walletIndex});this.addWalletConnector(s)}}}addImportedWalletConnector(e,t,r,a){let n=this.findWalletConnector("embedded_imported","privy");if(n&&xt(n))n.proxyProvider.walletProxy=e;else{let n=new de({provider:new Ir({walletProxy:e,address:t,entropyId:t,entropyIdVerifier:"ethereum-address-verifier",walletIndex:0,rpcConfig:this.rpcConfig,chains:this.chains,appId:a,chainId:r.id}),chains:this.chains,walletIndex:0,defaultChain:r,rpcConfig:this.rpcConfig,imported:!0});this.addWalletConnector(n)}}removeEmbeddedWalletConnectors(){this.walletConnectors=this.walletConnectors.filter((e=>"embedded"!==e.connectorType)),this.saveConnectionHistory(),this.storedConnections=kr(),this.emit("walletsUpdated")}removeImportedWalletConnector(){let e=this.findWalletConnector("embedded_imported","privy");if(e){let t=this.walletConnectors.indexOf(e);this.walletConnectors.splice(t,1),this.saveConnectionHistory(),this.storedConnections=kr(),this.emit("walletsUpdated")}}async createEthereumWalletConnector(e,t,r){let a=this.findWalletConnector(e,t);if(a&&xt(a))return a instanceof Ne&&a.resetConnection(t),a;let n=(()=>"injected"!==e?"coinbase_wallet"===e?new ce(this.chains,this.defaultChain,this.rpcConfig,this.externalWalletConfig,this.privyAppName,this.privyAppLogo):"phantom"===e?new Ht(this.defaultChain):new Ne(this.walletConnectCloudProjectId,this.rpcConfig,this.chains,this.defaultChain,this.shouldEnforceDefaultChainOnConnect,this.privyAppId,this.privyAppName,t):"metamask"===t&&r?.eip6963InjectedProvider?new Vt(this.chains,this.defaultChain,this.rpcConfig,r?.eip6963InjectedProvider,"metamask"):"metamask"===t&&r?.legacyInjectedProvider?new jt(this.chains,this.defaultChain,this.rpcConfig,r?.legacyInjectedProvider,"metamask"):"phantom"===t&&r?.legacyInjectedProvider?new jt(this.chains,this.defaultChain,this.rpcConfig,r?.legacyInjectedProvider,"phantom"):r?.legacyInjectedProvider&&"unknown_browser_extension"===t?new jt(this.chains,this.defaultChain,this.rpcConfig,r?.legacyInjectedProvider):r?.eip6963InjectedProvider?new Bt(this.chains,this.defaultChain,this.rpcConfig,r?.eip6963InjectedProvider,t):void 0)();return n&&this.addWalletConnector(n),n||null}addWalletConnector(e){this.walletConnectors.push(e),e.on("initialized",(()=>this.onInitialized(e))),e.on("walletsUpdated",(()=>this.onWalletsUpdated(e))),e.initialize().catch((e=>{console.debug("Failed to initialize connector",e)}))}saveConnectionHistory(){let e=this.wallets.map((e=>({address:e.address,connectorType:e.connectorType,walletClientType:e.walletClientType,connectedAt:e.connectedAt})));re.put(K,e)}async activeWalletSign(e){let t=this.wallets,r=t.length>0?t[0]:null;return r&&Te(r)?r.sign(e):null}setActiveWallet(e){this.activeWallet=r(e),this.emit("walletsUpdated")}constructor(e,t,r,a,n,i,o,s,l,c,d,u){super(),this.addSolanaWalletConnector=async e=>{this.findSolanaWalletConnector("solana_adapter",e.walletClientType)||this.addWalletConnector(e)},this.getEthereumProvider=()=>{let e=this.wallets[0],t=this.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return e&&t?t.proxyProvider:new ve},this.privyAppId=e,this.walletConnectCloudProjectId=t,this.rpcConfig=r,this.chains=a,this.defaultChain=n,this.walletConnectors=[],this.initialized=!1,this.store=i,this.walletList=o,this.shouldEnforceDefaultChainOnConnect=s,this.externalWalletConfig=l,this.privyAppName=c,this.privyAppLogo=d,this.walletChainType=u||"ethereum-only",this.storedConnections=kr()}}const kr=()=>{let e=re.get(K);return e&&Array.isArray(e)&&e.map((e=>(e=>e&&"string"==typeof e.address&&"string"==typeof e.connectorType&&"string"==typeof e.walletClientType&&"number"==typeof e.connectedAt)(e))).every(Boolean)?e:[]};let Nr;var br=0,Ur="__private_"+br+++"__getOrGenerateClientAnalyticsId";class Or{initializeConnectorManager({walletConnectCloudProjectId:e,rpcConfig:t,chains:r,defaultChain:a,store:n,walletList:i,shouldEnforceDefaultChainOnConnect:o,externalWalletConfig:s,appName:l,walletChainType:c}){this.connectors||(this.connectors=new Wr(this.appId,e,t,r,a,n,i,o,s,l,void 0,c))}generateApi(){let e=new Gt({appId:this.appId,appClientId:this.appClientId,client:this,defaults:{baseURL:this.apiUrl,timeout:this.timeout}});return this.session.api=e,e}updateApiUrl(e){this.apiUrl=e||this.fallbackApiUrl,this.api=this.generateApi(),e&&(this.useServerCookies=!0)}authenticate(){if(!this.authFlow)throw new Fe("No auth flow in progress.");return this.session.authenticate(this.authFlow)}async link(){if(!this.authFlow)throw new Fe("No auth flow in progress.");let{oAuthTokens:e}=await this.session.link(this.authFlow);return{user:await this.getAuthenticatedUser(),oAuthTokens:e}}storeProviderAccessToken(e,t){this.session.storeProviderAccessToken(e,t)}getProviderAccessToken(e){return this.session.getProviderAccessToken(e)}async logout(){await this.session.destroy(),this.authFlow=void 0}clearProviderAcccessTokens(e){e.linkedAccounts.filter((e=>"cross_app"===e.type)).forEach((e=>{this.storeProviderAccessToken(e.providerApp.id,null)}))}startAuthFlow(e){return e.api=this.api,this.authFlow=e,this.authFlow}async initMfaSmsVerification(){try{await this.api.post($t,{action:"verify"})}catch(e){throw xe(e)}}async initMfaPasskeyVerification(){try{let e=await this.api.post(Yt,{});return qt(e.options)}catch(e){throw xe(e)}}async getCrossAppProviderDetails(e){try{return this._cachedProviderAppDetails[e]||(this._cachedProviderAppDetails[e]=await this.api.get(`/api/v1/apps/${e}/cross-app/details`)),this._cachedProviderAppDetails[e]}catch(e){console.error("Error fetching cross app provider details",e)}}async acceptTerms(){try{let e=await this.api.post(Xt,{});return N(e)}catch(e){throw je(e)}}async unlinkEmail(e){try{let t=await this.api.post(Qt,{address:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkPhone(e){try{let t=await this.api.post(Jt,{phoneNumber:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkEthereumWallet(e){try{let t=await this.api.post(Zt,{address:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkSolanaWallet(e){try{let t=await this.api.post(er,{address:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkOAuth(e,t){try{let r=await this.api.post(tr,{provider:e,subject:t});return await this.getAuthenticatedUser()??N(r)}catch(e){throw je(e)}}async unlinkFarcaster(e){try{let t=await this.api.post(rr,{fid:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkTelegram(e){try{let t=await this.api.post(ar,{telegram_user_id:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async unlinkPasskey(e){try{let t=await this.api.post(nr,{credential_id:e});return await this.getAuthenticatedUser()??N(t)}catch(e){throw je(e)}}async revokeDelegatedWallet(){try{await this.api.post(ir,{})}catch(e){throw je(e)}}async createAnalyticsEvent({eventName:e,payload:t,timestamp:r,options:a}){if("undefined"!=typeof window)try{this.clientAnalyticsId||console.warn("No client analytics id set, refusing to send analytics event"),await this.api.post(or,{event_name:e,client_id:this.clientAnalyticsId,payload:{...t||{},clientTimestamp:r?r.toISOString():(new Date).toISOString()}},{retry:-1,keepalive:a?.keepAlive??!1})}catch(e){}}async signMoonpayOnRampUrl(e){try{return this.api.post(sr,e)}catch(e){throw je(e)}}async initCoinbaseOnRamp(e){try{return this.api.post(lr,e)}catch(e){throw je(e)}}async getCoinbaseOnRampStatus({partnerUserId:e}){try{return this.api.get(`${cr}?partnerUserId=${e}`)}catch(e){throw je(e)}}async getAuthenticatedUser(){return this.session.hasRefreshCredentials()||this.session.hasRecoveryCredentials()?this.session.refresh():null}async getAccessToken(e){return await this.getPrivyAccessToken(e)||await this.getCustomerAccessToken(e)}async getCustomerAccessToken(e){return await this._getToken(vr.CUSTOMER,e)}async getPrivyAccessToken(e){return await this._getToken(vr.PRIVY,e)}async _getToken(e,t){return this.session.getToken(e)?this.session.hasActiveAccessToken(e)?this.session.hasRefreshCredentials(e)?W.parse(this.session.getToken(e))?.appId!==this.appId?(await this.logout(),null):this.session.getToken(e):(this.session.destroyLocalState(),null):!t?.disableAutoRefresh&&this.session.hasRefreshCredentials(e)?(await this.session.refresh(),this.session.getToken(e)):null:null}async getSmartWalletsConfig(){try{let e={},t=this.session.token;t&&(e.authorization=`Bearer ${t}`);let r=await this.api.get(`/api/v1/apps/${this.appId}/smart_wallets`,{baseURL:this.fallbackApiUrl,headers:e});return r.enabled?{enabled:r.enabled,smartWalletType:r.smart_wallet_type,configuredNetworks:r.configured_networks.map((e=>({chainId:e.chain_id,bundlerUrl:e.bundler_url,paymasterUrl:e.paymaster_url,paymasterContext:zt(e.paymaster_url,e.paymaster_context)})))}:{enabled:r.enabled}}catch(e){throw je(e)}}async getServerConfig(){try{let e={},t=this.session.token;t&&(e.authorization=`Bearer ${t}`);let r=await this.api.get(`/api/v1/apps/${this.appId}`,{baseURL:this.fallbackApiUrl,headers:e}),a=r.telegram_auth_config?{botId:r.telegram_auth_config.bot_id,botName:r.telegram_auth_config.bot_name,linkEnabled:r.telegram_auth_config.link_enabled,seamlessAuthEnabled:r.telegram_auth_config.seamless_auth_enabled}:void 0,n=r.funding_config?{methods:r.funding_config.methods,options:r.funding_config.options,defaultRecommendedAmount:r.funding_config.default_recommended_amount,defaultRecommendedCurrency:r.funding_config.default_recommended_currency,promptFundingOnWalletCreation:r.funding_config.prompt_funding_on_wallet_creation,crossChainBridgingEnabled:r.funding_config.cross_chain_bridging_enabled}:void 0;return{id:r.id,name:r.name,verificationKey:r.verification_key,logoUrl:r.logo_url||void 0,accentColor:r.accent_color||void 0,showWalletLoginFirst:r.show_wallet_login_first,allowlistConfig:{errorTitle:r.allowlist_config.error_title,errorDetail:r.allowlist_config.error_detail,errorCtaText:r.allowlist_config.cta_text,errorCtaLink:r.allowlist_config.cta_link},walletAuth:r.wallet_auth,solanaWalletAuth:r.solana_wallet_auth,emailAuth:r.email_auth,smsAuth:r.sms_auth,googleOAuth:r.google_oauth,twitterOAuth:r.twitter_oauth,discordOAuth:r.discord_oauth,githubOAuth:r.github_oauth,spotifyOAuth:r.spotify_oauth,instagramOAuth:r.instagram_oauth,tiktokOAuth:r.tiktok_oauth,linkedinOAuth:r.linkedin_oauth,appleOAuth:r.apple_oauth,farcasterAuth:r.farcaster_auth,passkeyAuth:r.passkey_auth,telegramAuth:r.telegram_auth,disablePlusEmails:r.disable_plus_emails,termsAndConditionsUrl:r.terms_and_conditions_url,embeddedWalletConfig:{createOnLogin:r.embedded_wallet_config?.create_on_login,userOwnedRecoveryOptions:r.embedded_wallet_config.user_owned_recovery_options,requireUserOwnedRecoveryOnCreate:r.embedded_wallet_config.require_user_owned_recovery_on_create},privacyPolicyUrl:r.privacy_policy_url,requireUsersAcceptTerms:r.require_users_accept_terms,customApiUrl:r.custom_api_url,walletConnectCloudProjectId:r.wallet_connect_cloud_project_id,fiatOnRampEnabled:r.fiat_on_ramp_enabled,captchaEnabled:r.captcha_enabled,captchaSiteKey:r.captcha_site_key,createdAt:new Date(1e3*r.created_at),updatedAt:new Date(1e3*r.updated_at),mfaMethods:r.mfa_methods,enforceWalletUis:r.enforce_wallet_uis,legacyWalletUiConfig:r.legacy_wallet_ui_config,telegramAuthConfiguration:a,fundingConfig:n}}catch(e){throw je(e)}}async getUsdTokenPrice(e){try{return(await this.api.get(`/api/v1/token_price?chainId=${e.id}&tokenSymbol=${e.nativeCurrency.symbol}`)).usd}catch(t){return void console.error(`Unable to fetch token price for chain with id ${e.id}`)}}async getUsdPriceForSol(){try{return(await this.api.get("/api/v1/token_price?chainId=0&tokenSymbol=SOL")).usd}catch(e){return void console.error("Unable to fetch token price for SOL")}}async requestFarcasterSignerStatus(e){try{return await this.api.post("/api/v1/farcaster/signer/status",{ed25519_public_key:e})}catch(e){throw console.error("Unable to fetch Farcaster signer status"),e}}async forkSession(){return await this.session.forkSession()}async generateSiweNonce({address:e,captchaToken:t}){try{return(await this.api.post(dr,{address:e,token:t})).nonce}catch(e){throw je(e)}}async authenticateWithSiweInternal({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n,mode:i}){return await this.api.post(ur,{message:e,signature:t,chainId:r,walletClientType:a,connectorType:n,mode:i})}async linkWithSiweInternal({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n}){return await this.api.post(hr,{message:e,signature:t,chainId:r,walletClientType:a,connectorType:n})}async linkSmartWallet({message:e,signature:t,smartWalletType:r}){try{let a=await this.api.post(pr,{message:e,signature:t,smart_wallet_type:r});return N(a)}catch(e){throw je(e)}}async linkWithSiwe({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n}){try{let i=await this.linkWithSiweInternal({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n});return N(i)}catch(e){throw je(e)}}async generateSiwsNonce({address:e,captchaToken:t}){try{return(await this.api.post(wr,{address:e,token:t})).nonce}catch(e){throw je(e)}}async authenticateWithSiwsInternal({message:e,signature:t,walletClientType:r,connectorType:a,mode:n}){return await this.api.post(mr,{message:e,signature:t,walletClientType:r,connectorType:a,mode:n})}async sendAccountTransferRequest({nonce:e,account:t,accountType:r,externalWalletMetadata:a,telegramAuthResult:n,farcasterEmbeddedAddress:i,oAuthUserInfo:o}){try{let s,l;switch(r){case"email":s=Ar,l={nonce:e,email:t};break;case"sms":s=_r,l={nonce:e,phoneNumber:t};break;case"siwe":if(s=Er,!a)throw Error("Wallet parameters must be defined");l={nonce:e,address:t,...a};break;case"farcaster":s=gr,l={nonce:e,farcaster_id:t,farcaster_embedded_address:i};break;case"telegram":s=fr,l={nonce:e,telegram_auth_result:n};break;case"custom":case"guest":case"passkey":throw Error("Invalid transfer account type");default:s=yr,l={nonce:e,userInfo:o}}let c=await this.api.post(s,l);return await this.getAuthenticatedUser()??N(c)}catch(e){throw je(e)}}async linkWithSiwsInternal({message:e,signature:t,walletClientType:r,connectorType:a}){return await this.api.post(Tr,{message:e,signature:t,walletClientType:r,connectorType:a})}async linkWithSiws({message:e,signature:t,walletClientType:r,connectorType:a}){try{let n=await this.linkWithSiwsInternal({message:e,signature:t,walletClientType:r,connectorType:a});return N(n)}catch(e){throw je(e)}}constructor({apiUrl:e=G,appId:t,appClientId:r,timeout:a=z}){Object.defineProperty(this,Ur,{value:Sr}),this._cachedProviderAppDetails={},this.apiUrl=e,this.fallbackApiUrl=this.apiUrl,this.useServerCookies=e!==G&&e.startsWith("https://privy."),this.timeout=a,this.appId=t,this.appClientId=r,this.clientAnalyticsId=function(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw TypeError("attempted to use private field on non-instance");return e}(this,Ur)[Ur](),Nr||(Nr=new Cr),this.session=Nr,this.api=this.generateApi(),this.session.client=this}}function Sr(){if("undefined"==typeof window)return null;try{let e=re.get(q);if("string"==typeof e&&e.length>0)return e}catch(e){}let e=I();try{return re.put(q,e),e}catch(t){return e}}class Rr{async handleSignMessage(e){if(!e.params||"string"!=typeof e.params.message)throw Error("Message must be provided as a string for Solana signMessage RPC");return await $r({message:e.params.message,address:this.address})}async request(e){if(console.debug("EmbeddedSolanaProvider.request() called with args",e),!await Vr())throw Error("User must be authenticated to use embedded Solana wallet");if(!await qr())throw new Fe("Unable to connect to Solana embedded wallet");if("signMessage"===e.method)return await this.handleSignMessage(e);throw Error("Embedded Solana provider does not yet support this RPC method.")}constructor(e,t){this.walletProxy=e,this.address=t}}let Pr,Dr,Lr,Mr,Fr,xr,jr;function Br(){return Pr?Pr.getCustomerAccessToken():Promise.resolve(re.get($)||null)}async function Vr(){return Pr?Pr.getAccessToken():Promise.resolve(re.get(Y)||re.get($)||null)}const Hr=(e,t,r)=>Dr(e,t,r),Kr=(e,t,r)=>Lr(e,t,r),Gr=(e,t,r,a)=>Mr(e,t,r,a),zr=()=>Fr(),qr=()=>xr(),$r=({message:e,address:t})=>jr({message:e,address:t});const Yr=({config:t,...r})=>{var a;if("undefined"!=typeof window&&0>["localhost","127.0.0.1"].indexOf(window.location.hostname)&&"https:"!==window.location.protocol)throw new Fe("Embedded wallet is only available over HTTPS");if("string"!=typeof(a=r.appId)||25!==a.length)throw new Fe("Cannot initialize the Privy provider with an invalid Privy app ID");Pr||(Pr=new Or({appId:r.appId,appClientId:r.clientId,apiUrl:r.apiUrl}));let n=Object.assign({},t);return void 0!==r.createPrivyWalletOnLogin&&void 0===n.embeddedWallets?.createOnLogin&&(n.embeddedWallets||(n.embeddedWallets={}),n.embeddedWallets.createOnLogin=r.createPrivyWalletOnLogin?"users-without-wallets":"off"),void 0!==r.createPrivyWalletOnLogin&&t?.embeddedWallets?.createOnLogin&&console.warn("Both `createPrivyWalletOnLogin` and `config.embeddedWallets.createOnLogin` are set. `createPrivyWalletOnLogin` is deprecated and should be removed."),/*#__PURE__*/e(me,{client:Pr,clientConfig:n,legacyCreateEmbeddedWalletFlag:r.createPrivyWalletOnLogin,children:/*#__PURE__*/e(ft,{children:/*#__PURE__*/e(Xr,{...r,client:Pr})})})};let Xr=I=>{let W=I.client,N=gt(),[V,H]=i(!1),[K,z]=i(!1),[$,Y]=i(!1),[se,ce]=i(null),[de,ue]=i([]),[me,We]=i([]),[xe,je]=i([]),ft=o(de),[Mt,Ft]=i(!1),[xt,jt]=i(null),[Bt,Vt]=i(!1),[Ht,Kt]=i({status:"disconnected",connectedWallet:null,connectError:null,connector:null,connectRetry:Ct}),[Gt,zt]=i({status:"initial"}),[qt,$t]=i({status:"initial"}),[Yt,Xt]=i({status:"initial"}),[Qt,Jt]=i({status:"initial"}),[Zt,er]=i({status:"initial"}),[tr,rr]=i(null),ar=ye(),nr=fe(),[ir,or]=i(!0),[sr,lr]=i({}),[cr,dr]=i(null),[ur,hr]=i(null),[pr,wr]=i(!1),[mr,yr]=i(!1),[fr,gr]=i(ar.customAuth?.enabled?{status:"initial"}:{status:"not-enabled"}),Er=o(null),_r=o(null),Ar=o(Wt),[Tr,vr]=i(!1);W.onStoreCustomerAccessToken=e=>{e&&kt(Ar,"accessToken","onAccessTokenGranted",e)},W.onDeleteCustomerAccessToken=()=>{ce(null),Y(!1),kt(Ar,"accessToken","onAccessTokenRemoved")};let Cr=o(null),Ir=o(null),Wr=o(!1),kr=({showWalletUIs:e,typedData:t})=>Wr.current?Wr.current:void 0!==e?!e:void 0!==ar.embeddedWallets.showWalletUIs?!ar.embeddedWallets.showWalletUIs:t?ar.embeddedWallets.noPromptOnSignature||(ar.legacyWalletUiConfig??!1):!!ar.embeddedWallets.noPromptOnSignature,Nr=e=>{jt(e),setTimeout((()=>{H(!0)}),15),W.createAnalyticsEvent({eventName:"modal_open",payload:{initialScreen:e}})},br=e=>{"off"!==ar.embeddedWallets.createOnLogin&&or(!0),Nr(e)};s((()=>{let e=[...b(se),U(se)].filter((e=>!!e));tr&&je(e.map((e=>({type:"solana",imported:e.imported,address:e.address,connectedAt:Date.now(),walletClientType:"privy",connectorType:"embedded",walletIndex:e.walletIndex??void 0,meta:{name:"Privy Wallet",icon:void 0,id:"io.privy.solana.wallet"},linked:!0,fund(){throw new Fe("'fund' is deprecated for Solana wallets - use 'fundWallet' instead")},unlink:()=>{throw new Fe("Cannot unlink an embedded Solana wallet")},getProvider:async()=>new Rr(tr,e.address),async signMessage(t){let r=await Vr();if(!r||!tr)throw new Fe("Must have valid access token and Privy wallet to send transaction",Be.MUST_BE_AUTHENTICATED);let a=e.imported?U(se):O(se);if(!a)throw new Fe("Attempting to sign a transaction without a root wallet");let{entropyId:n,entropyIdVerifier:i}=k(a);if(!await ua.recoverPrimaryWallet().catch((()=>!1)))throw new Fe("Wallet couldn't be connected",Be.UNKNOWN_CONNECT_WALLET_ERROR);if(!se)throw new Fe("Attempting to sign a transaction with no user initialized");let{response:o}=await tr.rpc({accessToken:r,entropyId:n,entropyIdVerifier:i,chainType:"solana",hdWalletIndex:this.walletIndex??0,request:{method:"signMessage",params:{message:Buffer.from(t).toString("base64")}}});return Buffer.from(o.data.signature,"base64")},async sendTransaction(e,t,r){let{signature:a}=await na({transaction:e,connection:t,transactionOptions:r,wallet:this});return a},async signTransaction(t){let r=await Vr();if(!r||!tr)throw new Fe("Must have valid access token and Privy wallet to send transaction",Be.MUST_BE_AUTHENTICATED);if(!await ua.recoverPrimaryWallet().catch((()=>!1)))throw new Fe("Wallet couldn't be connected",Be.UNKNOWN_CONNECT_WALLET_ERROR);let{entropyId:a,entropyIdVerifier:n}=k(e);return await Ge({tx:t,accessToken:r,walletProxy:tr,entropyId:a,entropyIdVerifier:n,transactingWalletAddress:this.address,transactingWalletIndex:this.walletIndex??0}),t},loginOrLink:async()=>{throw new Fe("Cannot login or link with an embedded Solana wallet")},disconnect:()=>{},isConnected:async()=>!0}))))}),[tr,se]),s((()=>{if(!se)return void W.connectors?.removeEmbeddedWalletConnectors();let e=S(se),t=R(se),r=P(se);e&&t.length||W.connectors?.removeEmbeddedWalletConnectors(),r||W.connectors?.removeImportedWalletConnector(),W.connectors?tr?(e&&W.connectors.addEmbeddedWalletConnectors({walletProxy:tr,rootWallet:e,embeddedWallets:t,defaultChain:ar.defaultChain,appId:I.appId}),r&&W.connectors.addImportedWalletConnector(tr,r.address,ar.defaultChain,I.appId)):console.debug("Failed to add embedded wallet connector: Wallet proxy not initialized"):console.debug("Failed to add embedded wallet connector: Client connectors not initialized")}),[tr,se]),s((()=>{tr&&ur?.(tr)}),[tr]);let Ur=o();s((()=>{(async()=>{if(!ar.customAuth?.enabled)return void gr({status:"not-enabled"});or(!0);let{getCustomAccessToken:e,isLoading:t}=ar.customAuth;if(K&&!t&&"loading"!==fr.status){gr({status:"loading"});try{let t=await e();if(t===Ur.current)return void gr({status:"done"});if(!t&&$)return Ur.current=t,await da.logout(),gr({status:"done"}),void kt(Ar,"customAuth","onUnauthenticated");if(!t)return Ur.current=t,void gr({status:"done"});W.startAuthFlow(new p(t));let{user:r,isNewUser:a}=await W.authenticate();if(!r)return await da.logout(),gr({status:"error",error:new Fe("Failed to sync with custom auth provider")}),void kt(Ar,"customAuth","onUnauthenticated");void 0!==a&&kt(Ar,"login","onComplete",r,a,!1,"custom",null),Ur.current=t,kt(Ar,"customAuth","onAuthenticated",{user:r}),gr({status:"done"}),ce(r||null),Ft(a||!1),Y(!0),yr(!0)}catch(e){if(console.warn(e),await da.logout(),kt(Ar,"customAuth","onUnauthenticated"),"User already exists with provided custom JWT account."===e.message)return void gr({status:"initial"});kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),gr({status:"error",error:e})}}})()}),["initial"===fr.status,ar.customAuth?.enabled,ar.customAuth?.getCustomAccessToken,ar.customAuth?.isLoading,K,$]),s((()=>{mr&&tr&&se&&D(se,ar.embeddedWallets.createOnLogin)&&(yr(!1),Jr(se,ee).catch(console.error))}),[mr&&tr&&se]),s((()=>{if(ar.externalWallets.solana.connectors)return ar.externalWallets.solana.connectors.onMount(),()=>ar.externalWallets.solana.connectors?.onUnmount()}),[ar.externalWallets.solana.connectors]),s((()=>{!K&&nr&&async function(){let e,t=Or(),r=Sr();(()=>{let e=new URLSearchParams(window.location.search).get("privy_token");if(!e)return;re.put(te,e);let t=new URL(window.location.href);t.searchParams.delete("privy_token"),window.history.pushState({},"",t)})();let a=n();W.initializeConnectorManager({walletConnectCloudProjectId:ar.walletConnectCloudProjectId,rpcConfig:ar.rpcConfig,chains:ar.chains,defaultChain:ar.defaultChain,store:a,walletList:ar.appearance.walletList,shouldEnforceDefaultChainOnConnect:ar.shouldEnforceDefaultChainOnConnect,externalWalletConfig:ar.externalWallets,appName:ar.name??"Privy",walletChainType:ar.appearance.walletChainType}),W.connectors?.on("connectorInitialized",(()=>{e&&clearTimeout(e);let t=W.connectors.walletConnectors.length,r=W.connectors.walletConnectors.reduce(((e,t)=>e+(t.initialized?1:0)),0);r===t?vr(!0):e=setTimeout((()=>{console.debug({message:"Unable to initialize all expected connectors before timeout",initialized:r,expected:t}),vr(!0)}),1500)})),W.connectors?.initialize().then((()=>{zr()}));let i=await W.getAuthenticatedUser(),o=!!i;ar.legal.requireUsersAcceptTerms&&i&&!i.hasAcceptedTerms?(await W.logout(),ua.setReadyToTrue(!0),kt(Ar,"logout","onSuccess")):(ar.customAuth?.enabled||(Y(!!i),i&&kt(Ar,"login","onComplete",i,!1,!0,null,null),ce(i)),t?Ir.current=o?"link":"login":r&&!o?(Ir.current="login",lr({telegramAuthModalData:{seamlessAuth:!0}}),br(At.TELEGRAM_AUTH_SCREEN)):ua.setReadyToTrue(!!i))}()}),[W,cr,K,nr]),s((()=>{if(K){if(!se||!se.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType)))return void wr(!0);wr(!!de.find((e=>"privy"===e.walletClientType)))}}),[K,se,de]);let Or=()=>{let e=Dt();return e.inProgress&&e.popupFlow?window.opener.location.origin!==window.location.origin?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Origins between parent and child windows do not match."}):"error"===e.authorizationCode?void window.opener.postMessage({type:"PRIVY_OAUTH_ERROR",error:"Something went wrong. Try again."}):void window.opener.postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}):(e.inProgress&&Ye(e.provider)&&!e.popupFlow&&(new BroadcastChannel(Xe).postMessage({type:"PRIVY_OAUTH_RESPONSE",stateCode:e.stateCode,authorizationCode:e.authorizationCode}),window.close()),!!e.inProgress&&!!e.withPrivyUi&&(W.startAuthFlow(new Lt(e)),br(At.AWAITING_OAUTH_SCREEN),!0))},Sr=()=>{let e=C();if(!e||!ar.loginMethods.telegram||!ar.loginConfig.telegramAuthConfiguration?.seamlessAuthEnabled)return;let t=new v;return W.startAuthFlow(t),"login-url"===e.flowType&&(t.meta.telegramWebAppData=void 0,t.meta.telegramAuthResult=e.authData),"web-app"===e.flowType&&(t.meta.telegramAuthResult=void 0,t.meta.telegramWebAppData=e.authData),!0},Br=async(e,t,r,a)=>{Hr(await(W.connectors?.createEthereumWalletConnector(e,t))||null,t,r,a)};async function Hr(e,t,r,a){if(!e)return Kt({status:"disconnected",connectedWallet:null,connectError:new He("Unable to connect to wallet."),connector:null,connectRetry:Ct}),a?.(null,r);Kt({status:"disconnected",connectedWallet:null,connectError:null,connector:e,connectRetry:Ct}),e instanceof Ne&&t&&await e.resetConnection(t),Kt({connector:e,status:"connecting",connectedWallet:null,connectError:null,connectRetry:()=>Hr(e,t,r,a)});try{let t=await e.connect({showPrompt:!0});if((!t||Te(t))&&ar.shouldEnforceDefaultChainOnConnect&&!ar.chains.find((e=>e.id===Number(t?.chainId.replace("eip155:",""))))&&("wallet_connect_v2"!==t?.connectorType||"metamask"!==t?.walletClientType)){Kt((t=>({...t,connector:e,status:"switching_to_supported_chain",connectedWallet:null,connectError:null,connectRetry:Ct})));try{await(t?.switchChain(ar.defaultChain.id)),t&&(t.chainId=le(oe(ar.defaultChain.id)))}catch{console.warn(`Unable to switch to default chain: ${ar.defaultChain.id}`)}}return Kt((e=>({...e,status:"connected",connectedWallet:t,connectError:null,connectRetry:Ct}))),t&&kt(Ar,"connectWallet","onSuccess",(e.chainType,t)),a?.(t,r)}catch(e){return e instanceof Ke?(console.warn(e.cause?e.cause:e.message),kt(Ar,"connectWallet","onError",e.privyErrorCode||Be.GENERIC_CONNECT_WALLET_ERROR)):(console.warn(e),kt(Ar,"connectWallet","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR)),Kt((t=>({...t,status:"disconnected",connectedWallet:null,connectError:e}))),a?.(null,r)}}let Kr=async(e,t,r)=>{if(null===e||!Te(e))return;let a=new E(e,W,t,r);W.startAuthFlow(a)},Gr=async(e,t)=>{if(null===e||!ke(e))return;let r=new _(e,W,t);W.startAuthFlow(r)},zr=()=>{let e=new URLSearchParams(window.location.search),t=e.get("privy_connector"),r=e.get("privy_wallet_client");if(!t||!r)return;if("phantom"!==r||Ae()||br(At.LOGIN_FAILED_SCREEN),!W.connectors)throw new Fe("Connector not initialized");Nr(At.AWAITING_CONNECTION);let a=new URL(window.location.href);a.searchParams.delete("privy_connector"),a.searchParams.delete("privy_wallet_client"),window.history.pushState({},"",a),Br(t,r,void 0,Kr)};s((()=>{K&&$&&null===se&&W.getAuthenticatedUser().then(ce)}),[K,$,se,W]);let qr=e=>{if(!$)throw kt(Ar,"linkAccount","onError",Be.MUST_BE_AUTHENTICATED,{linkMethod:e}),new Fe("User must be authenticated before linking an account.")},$r=()=>{qr("siwe"),Cr.current="siwe",Ir.current="link",Nr(At.LINK_WALLET_SCREEN)},Yr=e=>{if(!$||!se)return!1;if("privy"===e.walletClientType)return!0;for(let t of se.linkedAccounts)if("wallet"===t.type&&t.address===e.address&&"privy"!==t.walletClientType)return!0;return!1},Xr=async e=>{let t;if(!W.connectors)throw new Fe("Connector not initialized");t="ethereum"===e.type?W.connectors.findWalletConnector(e.connectorType,e.walletClientType)||null:W.connectors.findSolanaWalletConnector(e.connectorType,e.walletClientType)||null,Kt((r=>({...r,connector:t,status:"connected",connectedWallet:e,connectError:null,connectRetry:Ct}))),ar.captchaEnabled&&!$?(lr({captchaModalData:{callback:t=>Te(e)?Kr(e,t):Gr(e,t),userIntentRequired:!1,onSuccessNavigateTo:At.AWAITING_CONNECTION,onErrorNavigateTo:At.ERROR_SCREEN}}),br(At.CAPTCHA_SCREEN)):(Te(e)?await Kr(e):await Gr(e),br(At.AWAITING_CONNECTION))},Qr=()=>{ue((e=>{let t=W.connectors?.wallets.filter(Te).map((e=>({...e,linked:Yr(e),loginOrLink:async()=>{if(!await e.isConnected())throw new Fe("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Fe("Cannot link or login with embedded wallet");Xr(e)},fund:async t=>{await ua.fundWallet(e.address,t)},unlink:async()=>{if(!$)throw new Fe("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Fe("Cannot unlink an embedded wallet");ce(await W.unlinkEthereumWallet(e.address))}})))||[];return ge(e,t)?e:t})),We((e=>{let t=(W.connectors?.wallets??[]).concat(xe).filter(ke).map((e=>({...e,linked:Yr(e),loginOrLink:async()=>{if(!await e.isConnected())throw new Fe("Wallet is not connected");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Fe("Cannot link or login with embedded wallet");Xr(e)},fund:async()=>{throw new Fe("'fund' is deprecated for Solana wallets - use 'fundWallet' instead")},unlink:async()=>{if(!$)throw new Fe("User is not authenticated.");if("embedded"===e.connectorType&&"privy"===e.walletClientType)throw new Fe("Cannot unlink an embedded wallet");ce(await W.unlinkSolanaWallet(e.address))}})));return ge(e,t)?e:t}))};s((()=>{Qr()}),[se?.linkedAccounts,$,K,xe]),s((()=>{if(K){if(!W.connectors)throw new Fe("Connector not initialized");Qr(),W.connectors.on("walletsUpdated",Qr)}}),[K]),s((()=>{[...ar.loginMethodsAndOrder?.primary??[],...ar.loginMethodsAndOrder?.overflow??[]].filter((e=>e.startsWith("privy:"))).forEach((e=>W.getCrossAppProviderDetails(e.replace("privy:",""))))}),[!!W]),s((()=>{let e;if(!de[0])return;let t=de[0],r=ft.current.find((e=>e.address===t.address));if(e="privy"===t.walletClientType?se?.linkedAccounts.find((e=>"wallet"===e.type&&e.address===t.address&&"privy"===e.walletClientType)):se?.linkedAccounts.find((e=>"wallet"===e.type&&e.address===t.address&&"privy"!==e.walletClientType)),!r&&e){let t=Object.assign({},se);t.wallet=e&&{address:e.address,chainType:e.chainType,chainId:e.chainId,walletClient:e.walletClient,walletClientType:e.walletClientType,connectorType:e.connectorType,imported:e.imported,delegated:e.delegated,walletIndex:e.walletIndex},ce(t)}ft.current=de}),[de]);let Jr=async(e,t,r)=>{let a=S(e),n=L(e);if(r&&"walletIndex"in r)return ea(e,t,r.walletIndex,a,n);let i=r&&"createAdditional"in r&&r.createAdditional;if(a&&!i)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_ALREADY_EXISTS),Error("User already has an embedded wallet.");let[o,s]=await Promise.all([ua.initializeWalletProxy(t),Vr()]);if(!o&&ar.customAuth?.enabled)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(!o||!s||ar.embeddedWallets?.requireUserOwnedRecoveryOnCreate)return Zr();if(!a)return await o.create({accessToken:s,solanaAddress:n?.address}),ra(0,"ethereum");{let t=(M(e)?.walletIndex??0)+1,{entropyId:r,entropyIdVerifier:a}=k(O(e));return await ua.recoverPrimaryWallet(),await o.addWallet({accessToken:s,entropyId:r,entropyIdVerifier:a,chainType:"ethereum",hdWalletIndex:t}),ra(t,"ethereum")}},Zr=async()=>new Promise(((e,t)=>{or(!0),lr({createWallet:{onSuccess:t=>{kt(Ar,"createWallet","onSuccess",t),e(t)},onFailure:e=>{kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),t(e)},callAuthOnSuccessOnClose:!1}}),Nr(At.EMBEDDED_WALLET_ON_ACCOUNT_CREATE_SCREEN)})),ea=async(e,t,r,a,n)=>{if(r<0)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_CREATE_ERROR),Error(`A negative walletIndex (${r}) is invalid.`);let[i,o]=await Promise.all([ua.initializeWalletProxy(t),Vr()]);if(!i&&ar.customAuth?.enabled)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(!i||!o||ar.embeddedWallets?.requireUserOwnedRecoveryOnCreate){if(0==r)return Zr();throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Create wallet UI can only be displayed when walletIndex is 0.")}if(0==r){if(a)return a;await i.create({accessToken:o,solanaAddress:n?.address})}else{if(!a)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_CREATE_ERROR),Error("A user must have a wallet at HD index 0 before creating a wallet at greater HD indices.");let t=R(e).find((e=>e.walletIndex===r));if(t)return t;let{entropyId:n,entropyIdVerifier:s}=k(O(e));await ua.recoverPrimaryWallet(),await i.addWallet({accessToken:o,entropyId:n,entropyIdVerifier:s,chainType:"ethereum",hdWalletIndex:r})}return ra(r,"ethereum")},ta=async({user:e,wp:t,accessToken:r,walletIndex:a,ethereumWallet:n})=>{let i=b(e).find((e=>e.walletIndex===a));if(i)return i;if(0===a)await t.createSolana({accessToken:r,ethereumAddress:n?.address});else{let n=O(e);if(!n)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_CREATE_ERROR),Error("User must have a wallet at HD index 0 before creating a wallet at greater HD indices.");let{entropyId:i,entropyIdVerifier:o}=k(n);await ua.recoverPrimaryWallet(),await t.addWallet({accessToken:r,entropyId:i,entropyIdVerifier:o,chainType:"solana",hdWalletIndex:a})}return ra(a,"solana")},ra=async(e,t)=>{let r=await ua.refreshUser(),a=("ethereum"===t?R(r):b(r)).find((t=>t.walletIndex===e));if(!a)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");return kt(Ar,"createWallet","onSuccess",a),a},aa=(e,t,a,n)=>new Promise((async(i,o)=>{let{requesterAppId:s}=t||{};if(!$||!se)return kt(Ar,"sendTransaction","onError",Be.MUST_BE_AUTHENTICATED),void o(Error("User must be authenticated before signing with a Privy wallet"));let l=n??S(se)?.address;if(!l)throw new Fe("User must have an embedded wallet to send a transaction.");let{signingWallet:c,rootWallet:p}=x(se,l);if(!p||!c)return kt(Ar,"sendTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void o(Error("Must have a Privy wallet before signing"));or(!0);let w=ha.wallets.find((e=>"privy"===e.walletClientType&&r(e.address)===r(c.address))),m=await(w?.getEthereumProvider());if(!w||!m)throw new Fe(`Cannot sendTransaction before embedded wallet ${c.address} is connected`);let y=e.chainId?Number(e.chainId):qe(w.chainId);(e=>{if(!ar.chains.map((e=>e.id)).includes(e))throw new He(`Chain ID ${e} is not supported. It must be added to the config.supportedChains property of the PrivyProvider.`,Be.UNSUPPORTED_CHAIN_ID)})(y);let f=Object.assign({},e,{chainId:y});if(kr({showWalletUIs:t?.showWalletUIs}))(async()=>{let e=await Vr();if(!e||!tr)return kt(Ar,"sendTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void o(Error("Must have valid access token and Privy wallet to send transaction"));try{if(!await ua.recoverPrimaryWallet())return kt(Ar,"sendTransaction","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),void o(Error("Unable to connect to wallet"));let r=ne(f.chainId,ar.chains,ar.rpcConfig,{appId:I.appId}),a=await d(c.address,f,r);if(kr({showWalletUIs:t?.showWalletUIs})){let{totalGasEstimate:e}=await u(a,r),{hasSufficientFunds:t}=await Le(c.address,a,e,r);if(!t)throw new Ee(new _e("Wallet has insufficient funds for this transaction.",h.E32603_DEFAULT_INTERNAL_ERROR.eipCode))}let{entropyId:n,entropyIdVerifier:l}=k(p),w=await Me({accessToken:e,entropyId:n,entropyIdVerifier:l,transactingWallet:c,walletProxy:tr,transactionRequest:a,provider:r,requesterAppId:s});kt(Ar,"sendTransaction","onSuccess",w),i(w)}catch(e){kt(Ar,"sendTransaction","onError",Be.TRANSACTION_FAILURE),o(e)}})();else{let{entropyId:e,entropyIdVerifier:r}=k(p),n={entropyId:e,entropyIdVerifier:r,onCompleteNavigateTo:At.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:e=>{kt(Ar,"sendTransaction","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),o(e)}},l=lt(ar)?Pt({address:c.address,appConfig:ar,fundWalletConfig:a,methodScreen:At.FUNDING_METHOD_SELECTION_SCREEN,chainIdOverride:f.chainId,comingFromSendTransactionScreen:!0}):void 0;lr({connectWallet:n,sendTransaction:{transactionRequest:f,transactingWallet:c,entropyId:e,entropyIdVerifier:r,onSuccess:e=>{kt(Ar,"sendTransaction","onSuccess",e),i(e)},onFailure:e=>{kt(Ar,"sendTransaction","onError",Be.TRANSACTION_FAILURE),o(e)},uiOptions:t||{},fundWalletConfig:a,requesterAppId:s},funding:l}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),na=({transaction:e,connection:t,transactionOptions:r,fundWalletConfig:a,uiOptions:n,wallet:i})=>new Promise((async(o,s)=>{let{requesterAppId:l}=n||{};if(!$||!se)return kt(Ar,"sendSolanaTransaction","onError",Be.MUST_BE_AUTHENTICATED),void s(new Fe("User must be authenticated before signing with a Privy wallet",Be.MUST_BE_AUTHENTICATED));let c=i?se.linkedAccounts.find((e=>"wallet"===e.type&&e.address===i.address)):L(se);if(!c)return kt(Ar,"sendSolanaTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void s(new Fe("Must have a Privy wallet before signing",Be.EMBEDDED_WALLET_NOT_FOUND));or(!0);let{rootWallet:d}=F(se,c.address);if(!await ua.recoverPrimaryWallet().catch((()=>!1))||!d)throw kt(Ar,"sendSolanaTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),new Fe(`Cannot sendSolanaTransaction before embedded wallet ${c.address} is connected`,Be.EMBEDDED_WALLET_NOT_FOUND);if(kr({showWalletUIs:n?.showWalletUIs}))(async()=>{let a=await Vr();if(!a||!tr)return kt(Ar,"sendSolanaTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void s(new Fe("Must have valid access token and Privy wallet to send transaction",Be.EMBEDDED_WALLET_NOT_FOUND));try{if(!await ua.recoverPrimaryWallet())return kt(Ar,"sendSolanaTransaction","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),void s(new Fe("Unable to connect to wallet",Be.UNKNOWN_CONNECT_WALLET_ERROR));if(kr({showWalletUIs:n?.showWalletUIs})){let{instructions:r}=await pt(e,t);r.every((e=>e.hasFunds))||(kt(Ar,"sendSolanaTransaction","onError",Be.INSUFFICIENT_BALANCE),s(new Fe("Solana wallet has insufficient funds for this transaction.",Be.INSUFFICIENT_BALANCE)))}let{entropyId:i,entropyIdVerifier:l}=B(se),{signature:d,receipt:u}=await ze({accessToken:a,tx:e,connection:t,walletProxy:tr,transactionOptions:r,entropyId:i,entropyIdVerifier:l,transactingWalletAddress:c.address,transactingWalletIndex:c.walletIndex??0}),h=wt(d,u);kt(Ar,"sendSolanaTransaction","onSuccess",h),o(h)}catch(e){kt(Ar,"sendSolanaTransaction","onError",Be.TRANSACTION_FAILURE),s(e)}})();else{let{entropyId:i,entropyIdVerifier:u}=k(d),h={entropyId:i,entropyIdVerifier:u,onCompleteNavigateTo:At.EMBEDDED_WALLET_SEND_SOLANA_TRANSACTION_SCREEN,onFailure:e=>{kt(Ar,"sendSolanaTransaction","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),s(e)}},p=lt(ar)?Rt({address:c.address,appConfig:ar,methodScreen:At.FUNDING_METHOD_SELECTION_SCREEN,fundWalletConfig:a,comingFromSendTransactionScreen:!0}):void 0;lr({connectWallet:h,sendSolanaTransaction:{transactionRequest:e,connection:t,transactionOptions:r,transactingWallet:c,onSuccess:e=>{kt(Ar,"sendSolanaTransaction","onSuccess",e),o(e)},onFailure:e=>{kt(Ar,"sendSolanaTransaction","onError",Be.TRANSACTION_FAILURE),s(e)},uiOptions:n||{},requesterAppId:l},funding:p}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}}));function ia(){return new Promise((async(e,t)=>{let r=await Vr();if(!r||!tr)throw Error("Must have valid access token to enroll in MFA");try{await tr.verifyMfa({accessToken:r}),e()}catch(e){t(e)}}))}let oa=e=>e?.linkedAccounts.filter((e=>null!==e.latestVerifiedAt&&!("wallet"===e.type&&"privy"===e.walletClientType))).sort(((e,t)=>t.latestVerifiedAt.getTime()-e.latestVerifiedAt.getTime()))[0],sa=e=>{let t=se?.linkedAccounts.filter((t=>t.type===e)).length??0,{displayName:r,loginMethod:a}=mt(e);if("passkey"===e&&t>=5||"passkey"!==e&&t>=1)throw kt(Ar,"linkAccount","onError",Be.CANNOT_LINK_MORE_OF_TYPE,{linkMethod:a}),new Fe(`User already has an account of type ${r} linked.`)};async function la({showAutomaticRecovery:e=!1,legacySetWalletPasswordFlow:t=!1}){jt(null);let r=t?"setWalletPassword":"setWalletRecovery";if(!$||!se)throw kt(Ar,r,"onError",Be.MUST_BE_AUTHENTICATED),Error("User must be authenticated before adding recovery method to Privy wallet");let a=O(se);if(!a||!tr)throw kt(Ar,r,"onError",Be.EMBEDDED_WALLET_NOT_FOUND),Error("Must have a Privy wallet to add a recovery method");try{await ia()}catch(e){throw kt(Ar,r,"onError",Be.MISSING_MFA_CREDENTIALS),e}return new Promise(((n,i)=>{or(!0);let o={onSuccess:e=>{kt(Ar,r,"onSuccess","user-passcode",e),n(e)},onFailure:e=>{kt(Ar,r,"onError",Be.USER_EXITED_SET_PASSWORD_FLOW),i(e)},callAuthOnSuccessOnClose:!1},s="user-passcode"===a.recoveryMethod,l=it({walletAction:"update",availableRecoveryMethods:ar.embeddedWallets.userOwnedRecoveryOptions,legacySetWalletPasswordFlow:t,isResettingPassword:s,showAutomaticRecovery:e}),{entropyId:c,entropyIdVerifier:d}=k(a);lr({setWalletPassword:o,recoverWallet:{entropyId:c,entropyIdVerifier:d,onFailure:i},createWallet:o,connectWallet:{onCompleteNavigateTo:l,shouldForceMFA:!1,entropyId:c,entropyIdVerifier:d,onFailure:e=>{kt(Ar,r,"onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),i(e)}},recoverySelection:{isInAccountCreateFlow:!1,isResettingPassword:s}}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}))}async function ca({appId:e,action:t}){let r=await Vr();if("link"===t&&!r)throw kt(Ar,"linkAccount","onError",Be.MUST_BE_AUTHENTICATED,{linkMethod:`privy:${e}`}),new Fe("User must be authenticated before linking an account.");if("login"===t&&r)throw kt(Ar,"login","onError",Be.UNKNOWN_AUTH_ERROR),new Fe("Attempted to log in, but user is already logged in. Use a `link` helper instead.");Cr.current=`privy:${e}`,Ir.current=t;let a=dt();return W.createAnalyticsEvent({eventName:"cross_app_auth_started",payload:{providerAppId:e}}),new Promise((async(r,n)=>{let{name:i,logoUrl:o}=await Ze({api:W.api,providerAppId:e,requesterAppId:ar.id});lr({crossAppAuth:{appId:e,name:i,logoUrl:o,action:t,popup:a,onSuccess:r,onError:n}}),br(At.CROSS_APP_AUTH_SCREEN)}))}let da={ready:K,authenticated:$,user:se,walletConnectors:W.connectors||null,connectWallet:e=>{e&&"target"in e&&e&&(e=void 0),lr({externalConnectWallet:{walletList:e?.walletList&&e?.walletList.length>0?e.walletList:void 0,suggestedAddress:e?.suggestedAddress}}),Nr($?At.CONNECT_ONLY_AUTHENTICATED_SCREEN:At.CONNECT_ONLY_LANDING_SCREEN)},linkWallet:$r,startCrossAppAuthFlow:ca,linkEmail:()=>{qr("email"),sa("email"),Cr.current="email",Ir.current="link",Nr(At.LINK_EMAIL_SCREEN)},linkPhone:()=>{qr("sms"),sa("phone"),Cr.current="sms",Ir.current="link",Nr(At.LINK_PHONE_SCREEN)},linkGoogle:async()=>{qr("google"),sa("google_oauth"),Ir.current="link",await ua.initLoginWithOAuth("google")},linkTwitter:async()=>{qr("twitter"),sa("twitter_oauth"),Ir.current="link",await ua.initLoginWithOAuth("twitter")},linkDiscord:async()=>{qr("discord"),sa("discord_oauth"),Ir.current="link",await ua.initLoginWithOAuth("discord")},linkGithub:async()=>{qr("github"),sa("github_oauth"),Ir.current="link",await ua.initLoginWithOAuth("github")},linkSpotify:async()=>{qr("spotify"),sa("spotify_oauth"),Ir.current="link",await ua.initLoginWithOAuth("spotify")},linkInstagram:async()=>{qr("instagram"),sa("instagram_oauth"),Ir.current="link",await ua.initLoginWithOAuth("instagram")},linkTiktok:async()=>{qr("tiktok"),sa("tiktok_oauth"),Ir.current="link",await ua.initLoginWithOAuth("tiktok")},linkLinkedIn:async()=>{qr("linkedin"),sa("linkedin_oauth"),Ir.current="link",await ua.initLoginWithOAuth("linkedin")},linkApple:async()=>{qr("apple"),sa("apple_oauth"),Ir.current="link",await ua.initLoginWithOAuth("apple")},linkPasskey:async()=>{qr("passkey"),sa("passkey"),await ua.initLinkWithPasskey(),Nr(At.LINK_PASSKEY_SCREEN)},linkTelegram:async()=>{qr("telegram"),sa("telegram"),Ir.current="link",Cr.current="telegram",await ua.initLoginWithTelegram(),Nr(At.TELEGRAM_AUTH_SCREEN)},linkFarcaster:async()=>{qr("farcaster"),sa("farcaster"),await ua.initLoginWithFarcaster(),Ir.current="link",Cr.current="farcaster",Nr(At.AWAITING_FARCASTER_CONNECTION)},updateEmail:()=>{if(qr("email"),!se?.email)throw new Fe("User does not have an email linked to their account.");Ir.current="update",Cr.current="email",Nr(At.UPDATE_EMAIL_SCREEN)},updatePhone:()=>{if(qr("sms"),!se?.phone)throw new Fe("User does not have a phone number linked to their account.");Ir.current="update",Cr.current="sms",Nr(At.UPDATE_PHONE_SCREEN)},login:async e=>{e&&"target"in e&&e&&(e=void 0);let t="Attempted to log in, but user is already logged in. Use a `link` helper instead.";if(!K){let e=await new Promise((e=>{dr((t=>e.bind(t)))}));if(dr(null),e)return void console.warn(t)}!se||se.isGuest?(Ir.current="login",lr({login:e}),br(At.LANDING)):console.warn(t)},connectOrCreateWallet:async()=>{K||(await new Promise((e=>{dr((()=>e))})),dr(null)),$?console.warn("User must be unauthenticated to `connectOrCreateWallet`"):(Ir.current="login",br(At.CONNECT_OR_CREATE))},logout:async()=>{if(Ir.current=null,Cr.current=null,se&&W.clearProviderAcccessTokens(se),jt(null),await W.logout(),se&&tr)try{await tr.clearMfa({userId:se.id})}catch(e){}ce(null),Y(!1),kt(Ar,"logout","onSuccess"),H(!1),re.del(q),re.del(X(ar.id))},getAccessToken:()=>W.getCustomerAccessToken(),getEthereumProvider:()=>{if(!se||!se.wallet)return new ve;let e=de.find((e=>se.wallet&&e.address===se.wallet.address)),t=W.connectors?.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return e&&t?t.proxyProvider:new ve},getEthersProvider:()=>{if(!se||!se.wallet)return new a(new Ce(new ve));let e=de.find((e=>se.wallet&&e.address===se.wallet.address)),t=W.connectors?.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return new a(new Ce(e&&t?t.proxyProvider:new ve))},getWeb3jsProvider:()=>{if(!se||!se.wallet)return new Ie(new ve);let e=de.find((e=>se.wallet&&e.address===se.wallet.address)),t=W.connectors?.walletConnectors.find((t=>t.wallets.find((t=>t.address===e?.address))));return new Ie(e&&t?t.proxyProvider:new ve)},unlinkWallet:async e=>{let t;return ce(t=e.startsWith("0x")?await W.unlinkEthereumWallet(e):await W.unlinkSolanaWallet(e)),t},unlinkEmail:async e=>{let t=await W.unlinkEmail(e);return ce(t),t},unlinkPhone:async e=>{let t=await W.unlinkPhone(e);return ce(t),t},unlinkGoogle:async e=>{let t=await W.unlinkOAuth("google",e);return ce(t),t},unlinkTwitter:async e=>{let t=await W.unlinkOAuth("twitter",e);return ce(t),t},unlinkDiscord:async e=>{let t=await W.unlinkOAuth("discord",e);return ce(t),t},unlinkGithub:async e=>{let t=await W.unlinkOAuth("github",e);return ce(t),t},unlinkSpotify:async e=>{let t=await W.unlinkOAuth("spotify",e);return ce(t),t},unlinkInstagram:async e=>{let t=await W.unlinkOAuth("instagram",e);return ce(t),t},unlinkTiktok:async e=>{let t=await W.unlinkOAuth("tiktok",e);return ce(t),t},unlinkLinkedIn:async e=>{let t=await W.unlinkOAuth("linkedin",e);return ce(t),t},unlinkApple:async e=>{let t=await W.unlinkOAuth("apple",e);return ce(t),t},unlinkFarcaster:async e=>{let t=await W.unlinkFarcaster(e);return ce(t),t},unlinkTelegram:async e=>{let t=await W.unlinkTelegram(e);return ce(t),t},unlinkPasskey:async e=>{let t=await W.unlinkPasskey(e);return ce(t),t},unlinkCrossAppAccount:async({subject:e})=>{let t=se?.linkedAccounts.find((t=>"cross_app"===t.type&&t.subject===e))?.providerApp;if(!t)throw new Fe("Invalid subject");W.storeProviderAccessToken(t.id,null);let r=await W.unlinkOAuth(`privy:${t.id}`,e);return ce(r),r},setActiveWallet:async e=>{let t=de.find((t=>r(t.address)===r(e))),a=se?.linkedAccounts.find((t=>"wallet"===t.type&&r(t.address)===r(e)));if(t&&await t.isConnected())if(t.linked){let e=Object.assign({},se);e.wallet=a&&{address:a.address,chainType:a.chainType,chainId:a.chainId,walletClient:a.walletClient,walletClientType:a.walletClientType,connectorType:a.connectorType,imported:a.imported,delegated:a.delegated,walletIndex:a.walletIndex},ce(e)}else t.loginOrLink();else lr({externalConnectWallet:{suggestedAddress:e}}),$r()},forkSession:()=>W.forkSession(),createWallet:async e=>{if(e&&"target"in e&&e&&(e=void 0),!$||!se)throw kt(Ar,"createWallet","onError",Be.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");return Jr(se,15e3,e)},setWalletRecovery:async e=>la({legacySetWalletPasswordFlow:!1,showAutomaticRecovery:e?.showAutomaticRecovery??!1}),setWalletPassword:async()=>la({legacySetWalletPasswordFlow:!0,showAutomaticRecovery:!1}),signMessage:(e,t,r)=>new Promise((async(a,n)=>{let{requesterAppId:i}=t||{};if(!$||!se)return kt(Ar,"signMessage","onError",Be.MUST_BE_AUTHENTICATED),void n(Error("User must be authenticated before signing with a Privy wallet"));let o=r??S(se)?.address;if(!o)throw new Fe("User must have an embedded wallet to sign a message.");let{signingWallet:s,rootWallet:l}=x(se,o);if(!s||!l)return kt(Ar,"signMessage","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void n(Error("Must have a Privy wallet before signing"));if("string"!=typeof e||e.length<1)return kt(Ar,"signMessage","onError",Be.INVALID_MESSAGE),void n(Error("Message must be a non-empty string"));or(!0);let c=async()=>{if(!$)throw Error("User must be authenticated before signing with a Privy wallet");let t=await Vr();if(!tr||!t||!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");W.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_started",payload:{walletAddress:s.address,requesterAppId:i}});let{entropyId:r,entropyIdVerifier:a}=k(l),{response:n}=await tr.rpc({accessToken:t,entropyId:r,entropyIdVerifier:a,chainType:"ethereum",hdWalletIndex:s.walletIndex??0,requesterAppId:i,request:{method:"personal_sign",params:[e,s.address]}}),o=n.data;return W.createAnalyticsEvent({eventName:"embedded_wallet_sign_message_completed",payload:{walletAddress:s.address,requesterAppId:i}}),o};if(kr({showWalletUIs:t?.showWalletUIs}))try{let e=await c();kt(Ar,"signMessage","onSuccess",e),a(e)}catch(e){kt(Ar,"signMessage","onError",Be.UNABLE_TO_SIGN),n(e??new Ee("Unable to sign message"))}else{let{entropyId:r,entropyIdVerifier:i}=k(l);lr({signMessage:{method:"personal_sign",data:e,confirmAndSign:c,onSuccess:e=>{kt(Ar,"signMessage","onSuccess",e),a(e)},onFailure:e=>{kt(Ar,"signMessage","onError",Be.UNABLE_TO_SIGN),n(e)},uiOptions:t||{}},connectWallet:{entropyId:r,entropyIdVerifier:i,onCompleteNavigateTo:At.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{kt(Ar,"signMessage","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),n(e)}}}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),signTypedData:(e,t,r)=>new Promise((async(a,n)=>{let{requesterAppId:i}=t||{};if(!$||!se)return kt(Ar,"signTypedData","onError",Be.MUST_BE_AUTHENTICATED),void n(Error("User must be authenticated before signing with a Privy wallet"));let o=r??S(se)?.address;if(!o)throw new Fe("User must have an embedded wallet to sign a message.");let{signingWallet:s,rootWallet:l}=x(se,o);if(!l||!s)return kt(Ar,"signTypedData","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void n(Error("Must have a Privy wallet before signing"));or(!0);let c=ie(e),d=async()=>{if(!$)throw Error("User must be authenticated before signing with a Privy wallet");let e=await Vr();if(!tr||!e||!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");W.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_started",payload:{walletAddress:s.address,requesterAppId:i}});let{entropyId:t,entropyIdVerifier:r}=k(l),{response:a}=await tr.rpc({accessToken:e,entropyId:t,entropyIdVerifier:r,chainType:"ethereum",hdWalletIndex:s.walletIndex??0,requesterAppId:i,request:{method:"eth_signTypedData_v4",params:[s.address,c]}}),n=a.data;return W.createAnalyticsEvent({eventName:"embedded_wallet_sign_typed_data_completed",payload:{walletAddress:s.address,requesterAppId:i}}),n};if(kr({showWalletUIs:t?.showWalletUIs,typedData:!0}))try{let e=await d();kt(Ar,"signTypedData","onSuccess",e),a(e)}catch(e){kt(Ar,"signTypedData","onError",Be.UNABLE_TO_SIGN),n(e??new Ee("Unable to sign message"))}else{let{entropyId:e,entropyIdVerifier:r}=k(l);lr({signMessage:{method:"eth_signTypedData_v4",data:c,confirmAndSign:d,onSuccess:e=>{kt(Ar,"signTypedData","onSuccess",e),a(e)},onFailure:e=>{kt(Ar,"signTypedData","onError",Be.UNABLE_TO_SIGN),n(e)},uiOptions:t||{}},connectWallet:{entropyId:e,entropyIdVerifier:r,onCompleteNavigateTo:At.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{kt(Ar,"signMessage","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),n(e)}}}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),sendTransaction:async(e,t,r,a)=>{let n=await aa(e,t,r,a);return De(await n.wait())},sendSolanaTransaction:async(e,t,r,a,n,i)=>{let o=i?me.find((({address:e})=>e===i)):me.slice().sort(((e,t)=>(e.walletIndex??0)-(t.walletIndex??0)))[0];if(!o)throw kt(Ar,"sendSolanaTransaction","onError",Be.EMBEDDED_WALLET_NOT_FOUND),new Fe("Embedded wallet not found",Be.EMBEDDED_WALLET_NOT_FOUND);return await na({transaction:e,connection:t,transactionOptions:a,uiOptions:r,fundWalletConfig:n,wallet:o})},exportWallet:e=>new Promise((async(t,r)=>{if(!$||!se)return void r(Error("User must be authenticated before exporting their Privy wallet"));e&&"target"in e&&e&&(e=void 0);let a=e?.address??S(se)?.address;if(!a)return void r(Error("User does not have an HD Ethereum wallet. To export an imported wallet, pass the `address` of the wallet to `exportWallet`."));let{signingWallet:n,rootWallet:i}=x(se,a);if(!n||!i)return void r(Error("Must have a Privy wallet before exporting"));or(!0);let{entropyId:o,entropyIdVerifier:s}=k(i),l={entropyId:o,entropyIdVerifier:s,onCompleteNavigateTo:At.EMBEDDED_WALLET_KEY_EXPORT_SCREEN,onFailure:r,shouldForceMFA:!0};lr(sr),await Vr()&&tr?tr?(lr({keyExport:{appId:I.appId,appClientId:I.clientId,origin:W.apiUrl,walletToExport:n,primaryWallet:i,onSuccess:t,onFailure:r},connectWallet:l}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)):r(Error("Must have a Privy wallet before exporting")):r(Error("Must have valid access token to enroll in MFA"))})),promptMfa:ia,async init(e){switch(e){case"sms":return void await W.initMfaSmsVerification();case"passkey":return await W.initMfaPasskeyVerification();case"totp":return;default:throw Error(`Unsupported MFA method: ${e}`)}},async submit(e,t){switch(e){case"totp":case"sms":if("string"!=typeof t)throw new Fe("Invalid MFA code");Er.current?.resolve({mfaMethod:e,mfaCode:t,relyingParty:window.origin}),await new Promise(((e,t)=>{_r.current={resolve:e,reject:t}}));break;case"passkey":if("string"==typeof t)throw new Fe("Invalid authenticator response");let r=await import("@simplewebauthn/browser"),a=yt(await r.startAuthentication(t));Er.current?.resolve({mfaMethod:e,mfaCode:a,relyingParty:window.origin}),await new Promise(((e,t)=>{_r.current={resolve:e,reject:t}}));break;default:throw Er.current?.reject(new Fe("Unsupported MFA method")),new Fe(`Unsupported MFA method: ${e}`)}},cancel(){Er.current?.reject(new Fe("MFA canceled"))},async initEnrollmentWithSms(e){let t=await Vr();if(!t||!tr)throw Error("Must have valid access token to enroll in MFA");await tr.initEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber})},enrollInMfa:e=>new Promise(((t,r)=>{if(!e)return ua.closePrivyModal(),void t();ar.mfa.noPromptOnMfaRequired&&console.warn("[Privy Warning] Triggering the 'showMfaEnrollmentModal' function when 'noPromptOnMfaRequired' is set to true is unexpected. If this is intentional, ensure that you are building custom UIs for MFA verification."),lr({mfaEnrollmentFlow:{mfaMethods:ar.mfa.methods,onSuccess:t,onFailure:r}}),Nr(At.MFA_ENROLLMENT_FLOW_SCREEN)})),async initEnrollmentWithTotp(){let e=await Vr();if(!e||!tr)throw Error("Must have valid access token to enroll in MFA");let t=await tr.initEnrollMfa({method:"totp",accessToken:e});return{secret:t.secret,authUrl:t.authUrl}},async submitEnrollmentWithSms(e){let t=await Vr();if(!t||!tr)throw Error("Must have valid access token to enroll in MFA");await tr.submitEnrollMfa({method:"sms",accessToken:t,phoneNumber:e.phoneNumber,code:e.mfaCode}),ce(await W.getAuthenticatedUser())},async submitEnrollmentWithTotp(e){let t=await Vr();if(!t||!tr)throw Error("Must have valid access token to enroll in MFA");await tr.submitEnrollMfa({method:"totp",accessToken:t,code:e.mfaCode}),ce(await W.getAuthenticatedUser())},async initEnrollmentWithPasskey(){},async submitEnrollmentWithPasskey({credentialIds:e}){let t=await Vr();if(!t||!tr)throw Error("Must have valid access token to enroll in MFA");await tr.submitEnrollMfa({method:"passkey",accessToken:t,credentialIds:e}),ce(await W.getAuthenticatedUser())},async unenroll(e){let t=await Vr();if(!t||!tr)throw Error("Must have valid access token to remove MFA");"passkey"===e?await tr.submitEnrollMfa({method:"passkey",accessToken:t,credentialIds:[]}):await tr.unenrollMfa({method:e,accessToken:t}),ce(await W.getAuthenticatedUser())},requestFarcasterSignerFromWarpcast:async()=>{let e=await Vr(),t=se?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!e)throw Error("Must have valid access token to connect with Farcaster");if(!tr||!t)throw Error("Must have an embedded wallet to use Farcaster signers");if(!se?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");let r=await tr.initFarcasterSigner({address:t.address,hdWalletIndex:null,accessToken:e,mfaCode:null,mfaMethod:null,relyingParty:window.origin});"approved"===r.status&&ce(await W.getAuthenticatedUser()||se||null),lr({farcasterSigner:r}),Nr(At.AWAITING_FARCASTER_SIGNER)},getFarcasterSignerPublicKey:async()=>{let e,t=await Vr(),r=se?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!tr||!r)throw Error("Must have an embedded wallet to use Farcaster signers");if(!se?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!se.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");return e=se.farcaster.signerPublicKey.slice(2),Uint8Array.from(e.match(/.{1,2}/g).map((e=>parseInt(e,16))))},signFarcasterMessage:async e=>{let t=await Vr(),r=se?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!tr||!r)throw Error("Must have an embedded wallet to use Farcaster signers");if(!se?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");if(!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!se.farcaster?.signerPublicKey)throw Error("Must have a Farcaster signer public key to sign");let a=await import("@simplewebauthn/browser"),n=await tr.signFarcasterMessage({address:r.address,hdWalletIndex:null,accessToken:t,mfaCode:null,mfaMethod:null,payload:{hash:a.bufferToBase64URLString(e)},fid:BigInt(se.farcaster.fid),relyingParty:window.origin});return new Uint8Array(a.base64URLStringToBuffer(n.signature))},createGuestAccount:async()=>{if(se&&!se.isGuest)throw Error("User cannot already be authenticated to create a guest account");return se?.isGuest?se:ua.loginWithGuestAccountFlow()},signMessageWithCrossAppWallet(e,{address:t}){let r=se?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return tt({user:se,client:W,address:t,requesterAppId:ar.id,request:{method:r?"privy_signSmartWalletMessage":"personal_sign",params:[e,t]},reconnect:ca})},signTypedDataWithCrossAppWallet(e,{address:t}){let r=se?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t)))),a=ie(e);return tt({user:se,client:W,address:t,requesterAppId:ar.id,request:{method:r?"privy_signSmartWalletTypedData":"eth_signTypedData_v4",params:[t,a]},reconnect:ca})},sendTransactionWithCrossAppWallet(e,{address:t}){let r=se?.linkedAccounts.some((e=>"cross_app"===e.type&&e.smartWallets.some((e=>e.address===t))));return tt({user:se,client:W,address:t,requesterAppId:ar.id,request:{method:r?"privy_sendSmartWalletTx":"eth_sendTransaction",params:[e]},reconnect:ca})},isModalOpen:V,mfaMethods:ar.mfa.methods};Dr=da.signMessage,Lr=da.signTypedData,Mr=async(...e)=>{let t=await aa(...e);return ar.embeddedWallets.waitForTransactionConfirmation&&await t.wait(),t};let ua={setAuthenticated:Y,setUser:ce,isNewUserThisSession:Mt,pendingTransaction:null,walletConnectionStatus:Ht,connectors:W.connectors?.walletConnectors??[],solanaWallets:me,rpcConfig:ar.rpcConfig,chains:ar.chains,appId:I.appId,showFiatPrices:"native-token"!==ar.embeddedWallets.priceDisplay.primary,clientAnalyticsId:W.clientAnalyticsId,customAuthStatus:fr,noPromptOnSignature:Wr,emailOtpState:qt,setEmailOtpState:$t,smsOtpState:Yt,setSmsOtpState:Xt,oAuthState:Zt,setOAuthState:er,siweState:Qt,setSiweState:Jt,isHeadlessOAuthLoading:Bt,nativeTokenSymbolForChainId:e=>ar.chains.find((t=>t.id===Number(e)))?.nativeCurrency.symbol,initializeWalletProxy:async e=>{if(tr)return tr;let t=new Promise((e=>{hr((()=>t=>e(t)))})),r=new Promise((t=>setTimeout((()=>t(null)),e))),a=await Promise.race([t,r]);return hr(null),a},getAuthFlow:()=>W.authFlow,getAuthMeta:()=>W.authFlow?.meta,client:W,closePrivyModal:async(e={shouldCallAuthOnSuccess:!0,isSuccess:!1})=>{let t,r=K&&$&&se;r&&Cr.current&&(t=oa(se)),"login"===Ir.current?e.shouldCallAuthOnSuccess&&r&&Cr.current?(kt(Ar,"login","onComplete",se,Mt,!1,Cr.current,t??null),I.onSuccess?.(se,Mt)):kt(Ar,"login","onError",Be.USER_EXITED_AUTH_FLOW):"link"===Ir.current&&t?e.isSuccess&&r&&Cr.current?kt(Ar,"linkAccount","onSuccess",se,Cr.current,t):Cr.current&&kt(Ar,"linkAccount","onError",Be.USER_EXITED_LINK_FLOW,{linkMethod:Cr.current}):"update"===Ir.current&&t&&(e.isSuccess&&r&&Cr.current?kt(Ar,"update","onSuccess",se,Cr.current,t):Cr.current&&kt(Ar,"update","onError",Be.USER_EXITED_UPDATE_FLOW,{linkMethod:Cr.current}));let a=xt&&ot.includes(xt),n=xt===At.ERROR_SCREEN&&sr.errorModalData&&ot.includes(sr.errorModalData.previousScreen);if((a||n)&&sr.funding){let e,t=st[xt]??null;if("solana"===sr.funding.chainType){let r=N(Et);if(!r)return void console.warn("Unable to load solana plugin, skipping balance");try{e=BigInt(await r.getBalance({address:sr.funding.address,cluster:sr.funding.cluster}))}catch{console.error("Unable to pull wallet balance")}kt(Ar,"fundSolanaWallet","onUserExited",{address:sr.funding.address,cluster:sr.funding.cluster,fundingMethod:t,balance:e})}else{let r=ne(sr.funding.chain.id,ar.chains,ar.rpcConfig,{appId:I.appId});try{e=(await r.getBalance(sr.funding.address)).toBigInt()}catch{console.error("Unable to pull wallet balance")}kt(Ar,"fundWallet","onUserExited",{address:sr.funding.address,chain:sr.funding.chain,fundingMethod:t,balance:e})}}lr({...sr,externalConnectWallet:{suggestedAddress:void 0}}),Ir.current=null,Cr.current=null,Ft(!1),H(!1),setTimeout((()=>{W.authFlow=void 0}),200),W.createAnalyticsEvent({eventName:"modal_closed"})},solanaSignMessage:({message:e,address:t})=>new Promise((async(r,a)=>{if(!$||!se)return kt(Ar,"signMessage","onError",Be.MUST_BE_AUTHENTICATED),void a(Error("User must be authenticated before signing with a Privy wallet"));let n=t??L(se)?.address;if(!n)throw new Fe("User must have an embedded wallet to sign a message.");let{signingWallet:i,rootWallet:o}=F(se,n);if(!i||!o)return kt(Ar,"signMessage","onError",Be.EMBEDDED_WALLET_NOT_FOUND),void a(Error("Must have a Privy wallet before signing"));if("string"!=typeof e||e.length<1)return kt(Ar,"signMessage","onError",Be.INVALID_MESSAGE),void a(Error("Message must be a non-empty string"));or(!0);let s=async()=>{if(!$)throw Error("User must be authenticated before signing with a Privy wallet");let t=await W.getAccessToken();if(!t)throw Error("User must be authenticated to use their embedded wallet.");let r=ua.walletProxy??await ua.initializeWalletProxy(15e3);if(!r)throw Error("Failed to initialize embedded wallet proxy.");if(!await ua.recoverPrimaryWallet())throw Error("Unable to connect to wallet");if(!o)throw Error("No root wallet for signing wallet found");let{entropyId:a,entropyIdVerifier:n}=k(o),{response:s}=await r.rpc({accessToken:t,entropyId:a,entropyIdVerifier:n,chainType:"solana",hdWalletIndex:i.walletIndex??0,request:{method:"signMessage",params:{message:e}}});return s.data.signature};if(kr({showWalletUIs:void 0}))try{let e=await s();r({signature:e})}catch(e){a(e)}else{let{entropyId:t,entropyIdVerifier:n}=k(o);lr({signMessage:{method:"solana_signMessage",data:e,confirmAndSign:s,onSuccess:e=>{r({signature:e})},onFailure:e=>{a(e)},uiOptions:{}},connectWallet:{entropyId:t,entropyIdVerifier:n,onCompleteNavigateTo:At.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:e=>{kt(Ar,"signMessage","onError",Be.UNKNOWN_CONNECT_WALLET_ERROR),a(e)}}}),br(At.EMBEDDED_WALLET_CONNECTING_SCREEN)}})),openPrivyModal:Nr,connectWallet:Hr,initLoginWithWallet:async(e,t,r)=>{Te(e)?(Cr.current="siwe",Kr(e,t,r)):(Cr.current="siws",Gr(e,t))},loginWithWallet:async()=>{let e,t,r;if(!K)throw new Ve;if(W.authFlow instanceof E?e="siwe":W.authFlow instanceof _&&(e="siws"),!e)throw new Fe("Must initialize SIWE/SIWS flow first.");if(null!==await W.getAccessToken())try{({user:t}=await W.link()),Cr.current=e}catch(t){throw kt(Ar,"linkAccount","onError",t.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{({user:t,isNewUser:r}=await W.authenticate()),Cr.current=e}catch(e){throw kt(Ar,"login","onError",e.privyErrorCode||Be.GENERIC_CONNECT_WALLET_ERROR),e}ce(t||se||null),Ft(r||!1),Y(!0)},delegateWallet:async({address:e,chainType:t})=>new Promise((async(r,a)=>{let n=await Vr();if(!$||!se||!n)throw new Fe("User must be authenticated and have an embedded wallet to delegate actions.");if("solana"!==t&&"ethereum"!==t)throw new Fe("Only Solana and Ethereum embedded wallets are supported for delegation and revocation.");let i=ua.walletProxy??await ua.initializeWalletProxy(15e3);if(!i)throw new Fe("Wallet proxy not initialized.");if(Ue({address:e,chainType:t,user:se}))return r();let o=Oe({address:e,user:se}),s=Se({address:e,user:se});await ua.recoverPrimaryWallet(),lr({delegatedActions:{consent:{address:e,onDelegate:async()=>{await i.createDelegatedAction({accessToken:n,rootWallet:s,delegatedWallets:[o]}),await ua.refreshUser()},onSuccess:async()=>{r()},onError:async e=>{a(e)}}}}),Nr(At.EMBEDDED_WALLET_DELEGATED_ACTIONS_CONSENT_SCREEN)})),revokeDelegatedWallets:async()=>new Promise((async(e,t)=>{if(!$||!se)throw new Fe("User must be authenticated and have an embedded wallet to revoke a delegated wallet.");if(0===Re(se).length)throw new Fe("User has no delegated wallets to revoke.");lr({delegatedActions:{revoke:{onRevoke:async()=>{await W.revokeDelegatedWallet(),await ua.refreshUser()},onSuccess:async()=>{e()},onError:async e=>{t(e)}}}}),Nr(At.EMBEDDED_WALLET_DELEGATED_ACTIONS_REVOKE_SCREEN)})),initLoginWithFarcaster:async(e,t)=>{let r=new y(e,t);W.startAuthFlow(r);try{Cr.current="farcaster",await r.initializeFarcasterConnect()}catch(e){throw"login"===Ir.current?kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR):"link"===Ir.current&&kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR,{linkMethod:"farcaster"}),e}},loginWithFarcaster:async()=>{let e,t;if(!K)throw new Ve;if(!(W.authFlow instanceof y))throw new Fe("Must initialize Farcaster flow first.");if(null!==await W.getAccessToken())try{({user:e}=await W.link()),Cr.current="farcaster"}catch(e){throw kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"farcaster"}),e}else try{({user:e,isNewUser:t}=await W.authenticate()),Cr.current="farcaster"}catch(e){throw kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}ce(e||null),Ft(t||!1),Y(!0)},async loginWithGuestAccountFlow(){let e=new f(this.appId);W.startAuthFlow(e);try{Ir.current="login",Cr.current="guest";let{user:e,isNewUser:t}=await W.authenticate();if(t=t||!1,!e)throw new Fe("Unable to authenticate guest account");if(D(e,ar.embeddedWallets.createOnLogin))try{await Jr(e,15e3),e=await ua.refreshUser()}catch(t){ce(e),console.warn("Unable to create embedded wallet for guest account")}else ce(e);return Ft(t),Y(!0),kt(Ar,"login","onComplete",e,t,!1,"guest",null),e}catch(e){throw kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}},async crossAppAuthFlow({appId:e,popup:t,action:r}){let a=`privy:${e}`;Cr.current=a;let{url:n,stateCode:i,codeVerifier:o}=await Qe({api:W.api,appId:e});if(!n)throw W.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:"Unable to open cross-app auth popup",appId:e}}),new Fe("No authorization URL returned for cross-app auth.");try{let s=await et({url:n,popup:t,provider:a}),l=s.stateCode,c=s.authorizationCode;if(l!==i)throw W.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:a,storedStateCode:i??"",returnedStateCode:l??""}}),new Fe("Unexpected auth flow. This may be a phishing attempt.",void 0,Be.OAUTH_UNEXPECTED);let d=await Je({appId:e,codeVerifier:o,stateCode:l,authorizationCode:c,action:r,client:W});d&&W.storeProviderAccessToken(e,d);let u=await ua.refreshUser();if(!u)throw new Fe("Unable to update user");return W.createAnalyticsEvent({eventName:"cross_app_auth_completed",payload:{providerAppId:e}}),u}catch(e){throw W.createAnalyticsEvent({eventName:"cross_app_auth_error",payload:{error:e.toString(),provider:a}}),e}},async initLoginWithOAuth(e,t,r){if(Cr.current=e,!ae())return void br(At.IN_APP_BROWSER_LOGIN_NOT_POSSIBLE);if("google"===e&&ct(window.navigator.userAgent))return void br(At.IN_APP_BROWSER_LOGIN_NOT_POSSIBLE);"twitter"===e&&window.opener&&window.opener.postMessage({type:$e},"*"),re.del(Q),re.del(J);let a=new Lt({provider:e,disableSignup:!!r,withPrivyUi:!0});t&&a.addCaptchaToken(t),W.startAuthFlow(a);let n=await W.authFlow.getAuthorizationUrl();n&&n.url&&("twitter"===e&&c&&(n.url=n.url.replace("x.com","twitter.com")),window.location.assign(n.url))},async initLoginWithTelegram(e,t){if(!K)throw new Ve;Cr.current="telegram";let r=new v(e,t);W.startAuthFlow(r),r.meta.telegramWebAppData=void 0,r.meta.telegramAuthResult=await new Promise(((e,t)=>ar.loginConfig.telegramAuthConfiguration?window.Telegram?void window.Telegram.Login.auth({bot_id:ar.loginConfig.telegramAuthConfiguration.botId,request_access:!0},(r=>r?e(r):t(new Fe("Telegram auth failed or was canceled by the client")))):t(new Fe("Telegram was not initialized")):t(new Fe("Telegram Auth configuration is not loaded"))))},async loginWithTelegram(e){let t,r;if(!(W.authFlow instanceof v))throw new Fe("Must initialize Telegram flow before calling loginWithTelegram");if(W.authFlow.meta.captchaToken||=e,"login"===Ir.current)try{let e=await W.authenticate();t=e.user,r=e.isNewUser,Cr.current="telegram"}catch(e){throw kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}else{if("link"!==Ir.current)throw new Fe("Unknown auth intent");try{t=(await W.link()).user,Cr.current="telegram"}catch(e){throw kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"telegram"}),e}}ce(t),Ft(r||!1),Y(!0)},async recoveryOAuthFlow(e,t,r){let a,n;function i(t){if(!t)throw W.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:"Unable to open recovery OAuth popup",provider:e}}),new Fe("Recovery OAuth failed")}switch(e){case"google-drive":{let t,o,{url:s,codeVerifier:l,stateCode:c}=await rt({api:Pr.api,provider:e});i(s);try{let a=await ut({url:s,popup:r,provider:e});if(t=a.stateCode,o=a.authorizationCode,t!==c)throw W.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:c??"",returnedStateCode:t??""}}),new Fe("Unexpected auth flow. This may be a phishing attempt.",void 0,Be.OAUTH_UNEXPECTED)}catch(t){throw W.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:t.toString(),provider:e}}),new Fe("Recovery OAuth failed")}[a,n]=await Promise.all([Vr(),at({api:Pr.api,provider:e,codeVerifier:l,stateCode:t,authorizationCode:o})]);break}case"icloud":{let{url:t}=await rt({api:Pr.api,provider:e});i(t);let{ckWebAuthToken:o}=await ut({url:t,popup:r,provider:e});n=o,a=await Vr()}}if(!tr)throw new Fe("Cannot connect to wallet proxy");if(!a)throw new Fe("Unable to authorize user");switch(t){case"recover":{let t=sr.recoverWallet?.entropyId,r=sr.recoverWallet?.entropyIdVerifier;if(!t||!r)throw new Fe("Recovery OAuth failed");W.createAnalyticsEvent({eventName:"embedded_wallet_recovery_started",payload:{walletAddress:t,recoveryMethod:e}}),await tr.recover({accessToken:a,entropyId:t,entropyIdVerifier:r,recoveryAccessToken:n}),W.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:t,recoveryMethod:e}});break}case"create-wallet":{W.createAnalyticsEvent({eventName:"embedded_wallet_creation_started"}),await tr.create({accessToken:a,recoveryAccessToken:n,recoveryMethod:e});let t=S(await ua.refreshUser());if(!t)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");W.createAnalyticsEvent({eventName:"embedded_wallet_creation_completed",payload:{walletAddress:t.address}}),kt(Ar,"createWallet","onSuccess",t);break}case"set-recovery":{let t=O(se);if(!t)throw kt(Ar,"setWalletRecovery","onError",Be.EMBEDDED_WALLET_NOT_FOUND),Error("Embedded wallet not found");W.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_started",payload:{walletAddress:t.address,existingRecoveryMethod:t.recoveryMethod,targetRecoveryMethod:e}});let{entropyId:r,entropyIdVerifier:i}=k(t);await tr.setRecovery({accessToken:a,entropyId:r,entropyIdVerifier:i,recoveryMethod:e,recoveryAccessToken:n});let o=O(await ua.refreshUser());if(!o)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to set recovery on wallet");W.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_completed",payload:{walletAddress:t.address,existingRecoveryMethod:t.recoveryMethod,targetRecoveryMethod:e}}),kt(Ar,"setWalletRecovery","onSuccess",e,o);break}default:throw new Fe("Unsupported recovery action")}},async loginWithOAuth(e){let t,r,a;if(!(W.authFlow instanceof Lt))throw new Fe("Must initialize OAuth flow before calling loginWithOAuth");let n=re.get(Z),i=W.authFlow.meta.stateCode;if(n!==i)throw W.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e,storedStateCode:n??"",returnedStateCode:i??""}}),new Fe("Unexpected auth flow. This may be a phishing attempt.",void 0,Be.OAUTH_UNEXPECTED);if(null!==await W.getAccessToken())try{let r=await W.link();t=r.user,a=r.oAuthTokens,Cr.current=e}catch(t){throw kt(Ar,"linkAccount","onError",t.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}else try{let n=await W.authenticate();t=n.user,r=n.isNewUser,a=n.oAuthTokens,Cr.current=e}catch(t){throw"login"===Ir.current?kt(Ar,"login","onError",t.privyErrorCode||Be.UNKNOWN_AUTH_ERROR):"link"===Ir.current&&kt(Ar,"linkAccount","onError",t.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:e}),t}return ce(t),Ft(r||!1),Y(!0),a&&t&&kt(Ar,"oAuthAuthorization","onOAuthTokenGrant",a,{user:t}),a},passkeyAuthState:Gt,setPasskeyAuthState:zt,async initLoginWithPasskey({captchaToken:e,withPrivyUi:t}){let r=new g({captchaToken:e,setPasskeyAuthState:zt});W.startAuthFlow(r),Ir.current="login";try{Cr.current="passkey",zt({status:"generating-challenge"}),await r.initAuthenticationFlow(t),zt({status:"awaiting-passkey"})}catch(e){throw zt({status:"error",error:e}),kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}},async loginWithPasskey(){let e,t;if(!K)throw new Ve;if(!(W.authFlow instanceof g))throw new Fe("Must initialize Passkey flow first.");if("passkey"!==Cr.current){let e=new Fe("Must init login with Passkey flow first.");throw zt({status:"error",error:e}),e}let r=await Vr();try{Cr.current="passkey",zt({status:"awaiting-passkey"}),({user:e,isNewUser:t}=await W.authenticate())}catch(e){throw zt({status:"error",error:e}),kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}ce(e),Ft(t||!1),Y(!0),zt({status:"done"});let a=e?.linkedAccounts.find((({type:e})=>"passkey"===e))||null;return{user:e,isNewUser:t||!1,wasAlreadyAuthenticated:!!r,loginAccount:a}},async initLinkWithPasskey(e){let t=new g({captchaToken:e});W.startAuthFlow(t),Ir.current="link",Cr.current="passkey",zt({status:"generating-challenge"});try{await t.initLinkFlow(),zt({status:"awaiting-passkey"})}catch(e){throw kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR,{linkMethod:"passkey"}),zt({status:"error",error:e}),e}},async linkWithPasskey(){let e;if(!K)throw new Ve;if(!(W.authFlow instanceof g))throw new Fe("Must initialize Passkey flow first.");if("passkey"!==Cr.current)throw new Fe("Must init login with Passkey flow first.");try{Cr.current="passkey",({user:e}=await W.link())}catch(e){throw kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"passkey"}),e}return ce(e||se||null),zt({status:"done"}),e},async initLoginWithHeadlessOAuth(e,t,r){if(!ae())throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");if("google"===e&&ct(window.navigator.userAgent))throw Error("It looks like you're using an in-app browser.  To log in, please try again using an external browser.");let a=new Lt({provider:e,withPrivyUi:!1,disableSignup:r??!1});t&&a.addCaptchaToken(t),er({status:"loading"});let n=await W.startAuthFlow(a).getAuthorizationUrl();n?.url&&window.location.assign(n.url)},async loginWithHeadlessOAuth(e){let t,r,a;Vt(!0),er({status:"loading"}),W.startAuthFlow(new Lt(e));let n=re.get(Z),i=e.stateCode;if(n!==i)throw W.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:e.provider,storedStateCode:n??"",returnedStateCode:i??""}}),Vt(!1),new Fe("Unexpected auth flow. This may be a phishing attempt.",void 0,Be.OAUTH_UNEXPECTED);if(null!==await W.getAccessToken())try{({user:t,oAuthTokens:a}=await W.link()),Cr.current=e.provider;let r=oa(t);t&&r&&kt(Ar,"linkAccount","onSuccess",t,Cr.current,r)}catch(t){throw Vt(!1),kt(Ar,"linkAccount","onError",t.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:e.provider}),t}else try{({user:t,isNewUser:r,oAuthTokens:a}=await W.authenticate()),Cr.current=e.provider;let n=oa(t);t&&n&&void 0!==r&&kt(Ar,"login","onComplete",t,r,!1,Cr.current,n)}catch(e){throw Vt(!1),er({status:"error",error:e}),kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}return ce(t),Ft(r||!1),Y(!0),Vt(!1),er({status:"done"}),a&&t&&kt(Ar,"oAuthAuthorization","onOAuthTokenGrant",a,{user:t}),t??void 0},initLoginWithEmail:async({email:e,captchaToken:t,disableSignup:r,withPrivyUi:a})=>{let n=new m({email:e,captchaToken:t,disableSignup:r});W.startAuthFlow(n);try{Cr.current="email",$t({status:"sending-code"}),await n.sendCodeEmail({withPrivyUi:a}),$t({status:"awaiting-code-input"})}catch(e){throw $t({status:"error",error:e}),"login"===Ir.current?kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR):"link"===Ir.current&&kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"email"}),e}},initUpdateEmail:async(e,t,r)=>{let a=new w(e,t,r);W.startAuthFlow(a);try{await a.sendCodeEmail({withPrivyUi:!0})}catch(e){kt(Ar,"update","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR,{linkMethod:Cr.current})}},initUpdatePhone:async(e,t,r)=>{let a=new A(e,t,r);W.startAuthFlow(a);try{await a.sendSmsCode({withPrivyUi:!0})}catch(e){kt(Ar,"update","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR,{linkMethod:Cr.current})}},initLoginWithSms:async({phoneNumber:e,captchaToken:t,disableSignup:r,withPrivyUi:a})=>{Xt({status:"sending-code"});let n=new T({phoneNumber:e,captchaToken:t,disableSignup:r});W.startAuthFlow(n);try{Cr.current="sms",await n.sendSmsCode({withPrivyUi:a}),Xt({status:"awaiting-code-input"})}catch(e){throw Xt({status:"error",error:e}),"login"===Ir.current?kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR):"link"===Ir.current&&kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"sms"}),e}},resendEmailCode:async()=>{await(W.authFlow?.sendCodeEmail({withPrivyUi:!0}))},resendSmsCode:async()=>{await(W.authFlow?.sendSmsCode({withPrivyUi:!0}))},loginWithCode:async e=>{let t,r;function a(e){W.authFlow instanceof m?$t(e):W.authFlow instanceof T&&Xt(e)}if(a({status:"submitting-code"}),!K){let e=new Ve;throw a({status:"error",error:e}),e}if(W.authFlow instanceof m)W.authFlow.meta.emailCode=e.trim();else{if(!(W.authFlow instanceof T)){let e=new Fe("Must initialize a passwordless code flow first");throw a({status:"error",error:e}),e}W.authFlow.meta.smsCode=e.trim()}let n=await Vr();if("link"===Ir.current)try{({user:t}=await W.link())}catch(e){throw a({status:"error",error:e}),kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:Cr.current}),e}else if("update"===Ir.current)try{({user:t}=await W.link())}catch(e){throw a({status:"error",error:e}),kt(Ar,"update","onError",e.privyErrorCode||Be.FAILED_TO_UPDATE_ACCOUNT,{linkMethod:Cr.current}),e}else try{({user:t,isNewUser:r}=await W.authenticate())}catch(e){throw a({status:"error",error:e}),kt(Ar,"login","onError",e.privyErrorCode||Be.UNKNOWN_AUTH_ERROR),e}let i=t||se;ce(i||null),Ft(r||!1),Y(!0),a({status:"done"});let o=null;return W.authFlow instanceof m?o=i?.linkedAccounts.find((({type:e})=>"email"===e))||null:W.authFlow instanceof T&&(o=i?.linkedAccounts.find((({type:e})=>"phone"===e))||null),{user:i,isNewUser:r||!1,wasAlreadyAuthenticated:!!n,linkedAccount:o}},generateSiweMessage:async({address:e,chainId:t,captchaToken:r})=>{Ir.current="link",Cr.current="siwe",Jt({status:"generating-message"});let a=await W.generateSiweNonce({address:e,captchaToken:r});return Jt({status:"awaiting-signature"}),ht({address:e,chainId:t.replace("eip155:",""),nonce:a})},generateSiweMessageForSmartWallet:async({address:e,chainId:t})=>{let r=await W.generateSiweNonce({address:e});return ht({address:e,chainId:t.replace("eip155:",""),nonce:r})},linkSmartWallet:async({message:e,signature:t,smartWalletType:r})=>{let a;a=await W.linkSmartWallet({message:e,signature:t,smartWalletType:r}),ce((a=await ua.refreshUser()??a)||se||null)},linkWithSiwe:async({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n})=>{let i;qr("siwe");let o=null;try{Jt({status:"submitting-signature"}),i=await W.linkWithSiwe({message:e,signature:t,chainId:r,walletClientType:a,connectorType:n}),i=await ua.refreshUser()??i,Jt({status:"done"}),(o=oa(i)||null)&&kt(Ar,"linkAccount","onSuccess",i,"siwe",o)}catch(e){throw kt(Ar,"linkAccount","onError",e.privyErrorCode||Be.FAILED_TO_LINK_ACCOUNT,{linkMethod:"siwe"}),Ir.current=null,Cr.current=null,Jt({status:"error",error:e}),e}let s=i||se;return ce(s||null),Ir.current=null,Cr.current=null,{user:s,linkedAccount:o}},refreshUser:async()=>{let e=await W.getAuthenticatedUser();return Y(!!e),ce(e),e},walletProxy:tr,createAnalyticsEvent:({eventName:e,payload:t,timestamp:r})=>W.createAnalyticsEvent({eventName:e,payload:t,timestamp:r}),acceptTerms:async()=>{let e=await W.acceptTerms();return ce(e),e},getUsdTokenPrice:e=>W.getUsdTokenPrice(e),getUsdPriceForSol:()=>W.getUsdPriceForSol(),recoverPrimaryWallet:async e=>new Promise((async(t,r)=>{let a=O(e?.user??se)||P(e?.user??se)||U(e?.user??se),n=await Vr();if(!n||!tr||!a)return void r(Error("Must have valid access token and Privy wallet to recover wallet"));or(!0);let{entropyId:i,entropyIdVerifier:o}=k(a);try{await tr.connect({accessToken:n,entropyId:i,entropyIdVerifier:o}),t(!0)}catch(e){Pe(e)&&"privy"===a.recoveryMethod?(W.createAnalyticsEvent({eventName:"embedded_wallet_pinless_recovery_started",payload:{walletAddress:a.address}}),(await tr.recover({entropyId:i,entropyIdVerifier:o,accessToken:n})).entropyId||r(Error("Unable to recover wallet")),W.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:a.address}}),t(!0)):Pe(e)&&"privy"!==a.recoveryMethod?(lr({recoverWallet:{entropyId:i,entropyIdVerifier:o,onFailure:r,onSuccess:()=>t(!0)},recoveryOAuthStatus:{provider:a.recoveryMethod,action:"recover"}}),Nr(nt(a.recoveryMethod))):r(e)}})),createEmbeddedSolanaWallet:async e=>{if(e&&"target"in e&&(e=void 0),!$||!se)throw kt(Ar,"createWallet","onError",Be.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");return(async(e,t,r)=>{let a=S(e),n=L(e),i=r&&"createAdditional"in r&&r.createAdditional,o=r&&"walletIndex"in r?r.walletIndex:void 0,s=(j(e)?.walletIndex??-1)+1;if(n&&!i&&"number"!=typeof o)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_ALREADY_EXISTS),Error("User already has an embedded wallet.");if("number"==typeof o&&o<0)throw kt(Ar,"createWallet","onError",Be.EMBEDDED_WALLET_CREATE_ERROR),Error(`A negative walletIndex (${o}) is invalid.`);let[l,c]=await Promise.all([ua.initializeWalletProxy(t),Vr()]);if(!l||!c)throw kt(Ar,"createWallet","onError",Be.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");return await ta({user:e,wp:l,accessToken:c,walletIndex:o??s,ethereumWallet:a})})(se,15e3,e)},exportSolanaWallet:e=>new Promise((async(t,r)=>{if(!$||!se)return void r(Error("User must be authenticated before exporting their Privy wallet"));let a=e?.address??L(se)?.address;if(!a)return void r(Error("User does not have an HD Solana wallet."));let{signingWallet:n,rootWallet:i}=F(se,a);if(!n||!i)return void r(Error("Must have a Privy wallet before exporting"));if(or(!0),!await Vr()||!tr)return void r(Error("Must have valid access token to enroll in MFA"));if(!tr)return void r(Error("Must have a Privy wallet before exporting"));let{entropyId:o,entropyIdVerifier:s}=k(i);lr({connectWallet:{entropyId:o,entropyIdVerifier:s,onCompleteNavigateTo:At.EMBEDDED_WALLET_KEY_EXPORT_SCREEN,onFailure:r,shouldForceMFA:!0},keyExport:{appId:I.appId,appClientId:I.clientId,origin:W.apiUrl,walletToExport:n,primaryWallet:i,onSuccess:t,onFailure:r}}),Nr(At.EMBEDDED_WALLET_CONNECTING_SCREEN)})),setReadyToTrue:e=>{z(!0),cr?.(e)},updateWallets:()=>Qr(),fundWallet:async(e,t)=>{let r=At.FUNDING_METHOD_SELECTION_SCREEN;lr({funding:Pt({address:e,appConfig:ar,fundWalletConfig:t,methodScreen:r})}),Nr(r)},openModal:Nr,requestFarcasterSignerStatus:async e=>{let t=await Vr(),r=se?.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType));if(!t)throw Error("Must have valid access token to connect with Farcaster");if(!tr||!r)throw Error("Must have an embedded wallet to use Farcaster signers");if(!se?.farcaster?.fid)throw Error("Must have Farcaster account to use Farcaster signers");let a=await W.requestFarcasterSignerStatus(e);return"approved"===a.status&&ce(await W.getAuthenticatedUser()||se||null),a},connectCoinbaseSmartWallet:async()=>{ar.externalWallets.coinbaseWallet.connectionOptions="smartWalletOnly";let e=W.connectors?.findWalletConnector("coinbase_wallet","coinbase_smart_wallet")||W.connectors?.findWalletConnector("coinbase_wallet","coinbase_wallet");if(e)return e.updateConnectionPreference("smartWalletOnly"),Hr(e);await Br("coinbase_wallet","coinbase_smart_wallet")},initiateAccountTransfer:async({nonce:e,account:t,accountType:r,externalWalletMetadata:a,telegramAuthResult:n,farcasterEmbeddedAddress:i,oAuthUserInfo:o})=>{let s=await W.sendAccountTransferRequest({nonce:e,account:t,accountType:r,externalWalletMetadata:a,telegramAuthResult:n,farcasterEmbeddedAddress:i,oAuthUserInfo:o});return ce(s),s}};Fr=ua.recoverPrimaryWallet,xr=ua.recoverPrimaryWallet,jr=ua.solanaSignMessage;let ha=l((()=>({wallets:de,ready:pr&&Tr})),[de,pr,Tr]),pa=W.authFlow instanceof v,wa=!ar.headless&&ar.captchaEnabled&&!$&&(K||pa);/*#__PURE__*/return e(Ot.Provider,{value:da,children:/*#__PURE__*/e(Nt.Provider,{value:Ar,children:/*#__PURE__*/e(St.Provider,{value:ha,children:/*#__PURE__*/e(It,{...ar,children:/*#__PURE__*/t(bt.Provider,{value:ua,children:[/*#__PURE__*/e(_t,{children:/*#__PURE__*/t(Ut,{data:sr,setModalData:lr,setInitialScreen:jt,initialScreen:xt,authenticated:$,open:V,children:[I.children,wa&&/*#__PURE__*/e(he,{delayedExecution:!1}),/*#__PURE__*/e(vt,{theme:{...ar.appearance.palette||{}}}),!ar.render.standalone&&/*#__PURE__*/e(pe,{open:V})]})}),ir&&nr?/*#__PURE__*/e(be,{appId:I.appId,appClientId:I.clientId,clientAnalyticsId:W.clientAnalyticsId,origin:W.apiUrl,mfaMethods:se?.mfaMethods,mfaPromise:Er,mfaSubmitPromise:_r,onLoad:rr,onLoadFailed:()=>null}):null,ar.loginConfig.telegramAuthConfiguration&&
/*#__PURE__*/e(Tt,{$if:!0,children:/*#__PURE__*/e(we,{scriptHost:I.apiUrl||G,botUsername:ar.loginConfig.telegramAuthConfiguration.botName})})]})})})})})};export{Wr as C,Ir as E,Yr as P,Or as a,Rr as b,Vr as c,Hr as d,Kr as e,Gr as f,Br as g,zr as h,qr as i,$r as j,kr as l};
