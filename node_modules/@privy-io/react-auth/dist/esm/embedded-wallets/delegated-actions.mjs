import{getImportedPrivyEthereumWallet as e,getPrivyEthereumWallet as t}from"../client/user.mjs";import{PrivyClientError as r}from"../errors.mjs";import"@ethersproject/address";import"ofetch";const d=({address:e,user:t})=>{let d=t.linkedAccounts.find((t=>"wallet"===t.type&&"privy"===t.walletClientType&&t.address===e));if(!d)throw new r("Address to delegate is not associated with current user.");return{address:d.address,chainType:d.chainType,walletIndex:d.walletIndex??0}},s=({address:d,user:s})=>{let i,a=s.linkedAccounts.find((e=>"wallet"===e.type&&"privy"===e.walletClientType&&e.address===d));if(!a)throw new r("Address to delegate is not associated with current user.");if(!(i="ethereum"===a.chainType?a.imported?e(s):t(s):a))throw new r("Unable to determine root address for delegated address.");return{address:i.address,chainType:i.chainType,imported:i.imported}},i=e=>e.linkedAccounts.filter((e=>"wallet"===e.type&&"privy"===e.walletClientType&&e.delegated)),a=({address:e,chainType:t,user:r})=>!!i(r).find((r=>r.address===e&&r.chainType===t));export{d as getDelegatedWalletsData,i as getDelegatedWalletsForUser,s as getRootWalletDataForDelegation,a as isWalletDelegated};
